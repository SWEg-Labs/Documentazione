% Intestazione
\fancyhead[L]{1 \hspace{0.2cm} Architettura} % Testo a sinistra

\section{Architettura}
\label{sec:architettura}

Questa sezione fornisce una descrizione dettagliata dell'\emph{architettura logica}\textsubscript{\textbf{\textit{G}}} del prodotto software, illustrando le scelte progettuali adottate per garantire la corretta realizzazione del sistema. Saranno presentati le principali scelte e \emph{pattern architetturali}\textsubscript{\textbf{\textit{G}}}, e le \emph{componenti software}\textsubscript{\textbf{\textit{G}}} che compongono il sistema.

\subsection{Architettura logica}
L’architettura adottata nella realizzazione dell’applicativo si basa sul modello di \emph{architettura esagonale}\textsubscript{\textbf{\textit{G}}}. Il livello di \emph{business}\textsubscript{\textbf{\textit{G}}} del software è quindi indipendente dagli altri componenti, ovvero nulla presente all’esterno della logica di business può conoscere la sua \emph{implementazione}\textsubscript{\textbf{\textit{G}}}. Questo principio alla base dell’architettura esagonale ci permette di ottenere un prodotto software facilmente testabile e \emph{manutenibile}\textsubscript{\textbf{\textit{G}}}. Le componenti che devono restare indipendenti sono rappresentate dal \emph{Domain business model}\textsubscript{\textbf{\textit{G}}}, che non comunica mai direttamente con l’esterno.
Gli elementi che permettono il funzionamento dell’architettura esagonale sono i seguenti:
\begin{itemize}
    \item \textbf{\emph{Controller}}\textsubscript{\textbf{\textit{G}}}: contiene l'\emph{application logic}\textsubscript{\textbf{\textit{G}}} del sistema: gestisce le richieste in ingresso, valida i dati di tipo \emph{DTO}\textsubscript{\textbf{\textit{G}}} ricevuti in input, e li adatta verso un tipo di dato di business. Il \emph{Controller} ha poi il compito di chiamare uno \emph{UseCase} per eseguire la logica di business, adattare l'output ricevuto in un oggetto DTO e restituirlo al client.
    \item \textbf{\emph{UseCase}}\textsubscript{\textbf{\textit{G}}}: rappresenta un caso d'uso specifico del sistema, che viene implementato da un \emph{Service} per realizzare la logica di business.
    \item \textbf{\emph{Service}}\textsubscript{\textbf{\textit{G}}}: contiene la \emph{business logic}\textsubscript{\textbf{\textit{G}}} del sistema: esegue operazioni specifiche esclusive del dominio di interesse e delega le interazioni con le altre componenti ai \emph{Port}. I \emph{Service} possono interagire unicamente con tipi di dato di business, garantendo l'indipendenza della logica di business dal resto del sistema.
    \item \textbf{\emph{Port}}\textsubscript{\textbf{\textit{G}}}: definisce le interfacce attraverso le quali i \emph{Service} interagiscono con il mondo esterno, permettendo il salvataggio e recupero di dati persistenti senza modificare la logica di business.
    \item \textbf{\emph{Adapter}}\textsubscript{\textbf{\textit{G}}}: implementa una o più interfacce definite dai \emph{Port}, permettendo la comunicazione tra la logica di business e le tecnologie esterne di \emph{persistent logic}\textsubscript{\textbf{\textit{G}}}. L'\emph{adapter} si occupa di adattare i dati ricevuti dalla logica di business in un tipo \emph{Entity}\textsubscript{\textbf{\textit{G}}} adatto per la persistenza, e viceversa.
    \item \textbf{\emph{Repository}}\textsubscript{\textbf{\textit{G}}}: contiene la \emph{persistent logic} del sistema: gestisce la persistenza dei dati, interagendo con un database o altre forme di storage per salvare e/o recuperare le informazioni necessarie. I tipi di dato gestiti dal \emph{repository} sono gli \emph{Entity}, che rappresentano il livello intermedio che sta a contatto diretto con i dati persistenti del sistema.
\end{itemize}

È stato scelto di utilizzare un'architettura esagonale per i seguenti motivi:
\begin{itemize}
    \item \textbf{Facilità di test}: l'architettura esagonale permette di testare facilmente la business logic, in quanto è possibile sostituire gli adapter con degli \emph{stub}\textsubscript{\textbf{\textit{G}}} o dei \emph{mock}\textsubscript{\textbf{\textit{G}}};
    \item \textbf{\emph{Manutenibilità}}\textsubscript{\textbf{\textit{G}}}: l'architettura esagonale permette di mantenere la business logic indipendente dagli altri componenti, facilitando la manutenzione del codice;
    \item \textbf{\emph{Scalabilità}}\textsubscript{\textbf{\textit{G}}}: l'architettura esagonale permette di aggiungere nuovi adapter senza dover modificare la business logic.
\end{itemize}


\subsection{Architettura di Deployment}
\label{sec:architettura_deployment}

Per determinare l'\emph{architettura di deployment}\textsubscript{\textbf{\textit{G}}} più adatta all'applicativo, si è tenuto conto del contesto reale in cui verrà utilizzato. Poiché il sistema è destinato all'utilizzo in un'azienda, dove non si prevedono significative espansioni o modifiche strutturali dopo l'installazione, la scelta di un'architettura monolitica è risultata la più appropriata. Questa soluzione, oltre a essere perfettamente in linea con le esigenze del prodotto, semplifica le fasi di progettazione, sviluppo e test. Inoltre, rispetto a un'architettura a microservizi, la monolitica evita complessità che sarebbero state difficili da gestire, anche considerando le competenze attuali del team di sviluppo.\\\\
Il deployment del prodotto viene gestito attraverso la containerizzazione con \textbf{\emph{Docker Compose}}\textsubscript{\textbf{\textit{G}}}. Questa scelta consente di semplificare l’installazione dell’applicativo, fornendo un ambiente preconfigurato in cui tutte le dipendenze sono già risolte. In questo modo, vengono predisposti automaticamente tutti i servizi necessari per garantire il corretto funzionamento del sistema, riducendo le difficoltà legate alla configurazione manuale.



\subsection{Architettura di dettaglio}
\label{sec:architettura_di_dettaglio}

\subsubsection{Architettura della generazione di una risposta}
\label{sec:architettura_generazione_risposta}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura della generazione di una risposta}
\end{figure}

L'\emph{UML}\textsubscript{\textbf{\textit{G}}} in questione rappresenta l'\emph{architettura}\textsubscript{\textbf{\textit{G}}} della generazione di una risposta all'interrogazione di un utente, dal punto di vista del \emph{backend}\textsubscript{\textbf{\textit{G}}}.
Quando il \emph{frontend}\textsubscript{\textbf{\textit{G}}} invia al backend il messaggio dell'utente, in forma di dizionario, esso viene recuperato dal ChatController, che converte la stringa interna al dizionario in un oggetto di Business, Question, e lo invia all'interfaccia ChatUseCase, implementata da ChatService.
ChatService, quindi, chiama SimilaritySearchService, componente responsabile della ricerca di \emph{similarità}\textsubscript{\textbf{\textit{G}}} nel \emph{database vettoriale}\textsubscript{\textbf{\textit{G}}}, il quale si collega con SimilaritySearchPort verso l'esterno, sfruttando l'\emph{architettura esagonale}\textsubscript{\textbf{\textit{G}}}. La Porta viene implementata da ChromaVectorStoreAdapter, che adatta la Question verso un tipo stringa inviato a ChromaVectorStoreRepository, che gestisce il collegamento con il database vettoriale \emph{Chroma}\textsubscript{\textbf{\textit{G}}}, sul quale avviene la ricerca di similarità. Una volta ottenuti i risultati della ricerca e trasformati in \emph{Entity}\textsubscript{\textbf{\textit{G}}}, essi vengono convertiti nel tipo di Business Document e poi restituiti a ChatService, il quale dunque li invia assieme all'input dell'utente a GenerateAnswerService, classe di servizio munita di un attributo Header che consente di fornire un introduzione di contesto al chatbot. Header, input utente e documenti rilevanti vengono quindi forniti a LangChainAdapter, che si assicura che la somma dei \emph{token}\textsubscript{\textbf{\textit{G}}} dei parametri non superi la soglia limite per l'\emph{LLM}\textsubscript{\textbf{\textit{G}}} configurato. Infine, i parametri vengono forniti a LangChainRepository, che li combina assieme in unico prompt e, sfruttando gli strumenti forniti dalla libreria \emph{LangChain}\textsubscript{\textbf{\textit{G}}}, effettua una chiamata verso l'LLM di \emph{OpenAI}\textsubscript{\textbf{\textit{G}}}, selezionato tramite una variabile d'ambiente, per ottenere una risposta. 
La risposta viene quindi convertita in un oggetto Answer di \emph{Business Logic}\textsubscript{\textbf{\textit{G}}} ed infine convertita in stringa per essere inserita in un dizionario in ChatController, il quale restituisce la risposta al frontend.

\newpage


\subsubsection{Architettura dell'aggiornamento automatico del database vettoriale}
\label{sec:architettura_aggiornamento_database_vettoriale}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura dell'aggiornamento automatico del database vettoriale}
\end{figure}

\dots

\newpage


\subsubsection{Architettura dell’inizializzazione, refresh e scroll di Angular}
\label{sec:architettura_inizializzazione_angular}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura dell’inizializzazione, refresh e scroll di Angular}
\end{figure}

\dots

\newpage


\subsubsection{Architettura dell’aggiornamento del rendering grafico durante la chat}
\label{sec:architettura_aggiornamento_rendering_chat}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura dell’aggiornamento del rendering grafico durante la chat}
\end{figure}

\dots

\newpage


\subsubsection{Architettura frontend dell’aggiornamento del badge di segnalazione dell’esito dell’ultimo aggiornamento automatico}
\label{sec:architettura_frontend_badge_aggiornamento}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura frontend dell’aggiornamento del badge di segnalazione dell’esito dell’ultimo aggiornamento automatico}
\end{figure}

\dots

\newpage


\subsubsection{Architettura backend dell’aggiornamento del badge di segnalazione dell’esito dell’ultimo aggiornamento automatico}
\label{sec:architettura_backend_badge_aggiornamento}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura backend dell’aggiornamento del badge di segnalazione dell’esito dell’ultimo aggiornamento automatico}
\end{figure}

\dots

\newpage


\subsubsection{Architettura del salvataggio dei messaggi nello storico}
\label{sec:architettura_salvataggio_messaggi_storico}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura del salvataggio dei messaggi nello storico}
\end{figure}

\dots

\newpage


\subsubsection{Architettura del recupero dei messaggi dallo storico}
\label{sec:architettura_recupero_messaggi_storico}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura del recupero dei messaggi dallo storico}
\end{figure}

\dots

\newpage


\subsubsection{Architettura della generazione di domande per proseguire la conversazione}
\label{sec:architettura_generazione_domande_conversazione}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura della generazione di domande per proseguire la conversazione}
\end{figure}

\dots

\newpage



\subsection{Design pattern utilizzati}
\label{sec:design_pattern_utilizzati}


\subsubsection{Facade}
\label{sec:facade}

Il pattern \emph{Facade}\textsubscript{\textbf{\textit{G}}} è stato adottato per permettere al \emph{cron}\textsubscript{\textbf{\textit{G}}} di accedere ad unica classe LoadFilesService avente il compito di caricare tutti i tipi di file necessari per l'aggiornamento del database vettoriale. Questo pattern permette di nascondere la complessità del sistema, fornendo un'interfaccia semplificata per l'accesso alle funzionalità offerte dalla classe LoadFilesService. In questo modo, il cron non deve preoccuparsi di come i file vengono caricati, ma può semplicemente chiamare il metodo \texttt{load} della suddetta classe per ottenere il risultato desiderato.
E' stato inoltre adottato un piccolo Facade anche per l'architettura di generazione di una risposta, dove ChatService si occupa di nascondere la complessità della logica di business, fornendo un'interfaccia semplificata per l'accesso alle funzionalità offerte da SimilaritySearchService e GenerateAnswerService.
Grazie a questo pattern, è possibile mantenere il codice più pulito e manutenibile, in quanto la complessità è nascosta all'esterno e le interazioni con le classi interne sono semplificate.


\subsubsection{Dependency Injection}
\label{sec:dependency_injection}

Il pattern \emph{Dependency Injection}\textsubscript{\textbf{\textit{G}}} è stato adottato per permettere l'iniezione delle dipendenze all'interno delle classi del sistema. Questo pattern permette di separare la creazione degli oggetti dal loro utilizzo, semplificando la gestione delle dipendenze e rendendo il codice più manutenibile e testabile. In questo modo, le classi non devono preoccuparsi di come vengono creati gli oggetti di cui hanno bisogno, ma possono semplicemente riceverli come parametri di costruzione. Questo permette di sostituire facilmente le implementazioni delle dipendenze, senza dover modificare il codice di tutte le classi che le utilizzano. Inoltre, grazie all'utilizzo di un \emph{framework}\textsubscript{\textbf{\textit{G}}} di \emph{Dependency Injection}, come \emph{Angular}\textsubscript{\textbf{\textit{G}}}, è possibile automatizzare il processo di creazione e iniezione delle dipendenze, semplificando ulteriormente lo sviluppo del \emph{frontend}\textsubscript{\textbf{\textit{G}}}. Il pattern è stato implementato anche in \emph{Python}\textsubscript{\textbf{\textit{G}}} nel \emph{backend}\textsubscript{\textbf{\textit{G}}}, attraverso due funzioni, \texttt{dependency\_injection\_frontend} e \texttt{dependenc\_injection\_cron}, che si occupano di iniettare le dipendenze rispettivamente nel file di endpoint \emph{FastAPI}\textsubscript{\textbf{\textit{G}}} a cui accede il frontend per contattare il backend e nel file che viene eseguito periodicamente dal cron per l'aggiornamento del \emph{database vettoriale}\textsubscript{\textbf{\textit{G}}}.


\subsubsection{MVVM}
\label{sec:mvvm}

Il pattern \emph{MVVM}\textsubscript{\textbf{\textit{G}}} è stato adottato per la progettazione dell'architettura del \emph{frontend}, in particolare per separare la logica di presentazione dalla logica di business, semplificando la gestione delle interazioni tra i componenti dell'applicazione. Nello specifico, il \emph{Model}\textsubscript{\textbf{\textit{G}}} rappresenta i dati e la logica di business dell'applicazione, il \emph{View}\textsubscript{\textbf{\textit{G}}} si occupa della presentazione dei dati all'utente, e il \emph{ViewModel}\textsubscript{\textbf{\textit{G}}} si occupa di gestire la logica di presentazione e di coordinare le interazioni tra il \emph{Model} e la \emph{View}. Questo permette di mantenere il codice più pulito e manutenibile, in quanto la logica di business è separata dalla logica di presentazione, e le interazioni tra i componenti sono semplificate. Inoltre, grazie all'utilizzo di un \emph{framework} come \emph{Angular}, è possibile automatizzare il processo di creazione e gestione dei componenti, semplificando ulteriormente lo sviluppo del \emph{frontend}. Il pattern è stato implementato in \emph{Angular} attraverso la creazione di componenti per la \emph{View} e il \emph{ViewModel}, e la creazione di servizi per la gestione della logica di business del \emph{Model}.



\subsection{Descrizione delle classi}
\label{sec:descrizione_classi}

\subsubsection{Backend}
\label{sec:backend}

\subsubsubsection{Controller}
\label{sec:controller}

\paragraph{ChatController}
\label{sec:chat_controller}
La classe ChatController si occupa di mettere in contatto il frontend con il backend nell'architettura di generazione di una risposta. Attraverso il metodo \texttt{get\_answer(user\_input: Request): dict[string, string]}, riceve il messaggio dell'utente di tipo Request, dal quale ricava un dizionario, che poi converte in un oggetto di Business, Question, e lo invia all'interfaccia ChatUseCase. Riceve poi da essa in output un oggetto Answer, lo converte in stringa, lo inserisce in un dizionario e infine lo restituisce al frontend.


\subsubsubsection{Use Case}
\label{sec:use_case}

\paragraph{ChatUseCase}
\label{sec:chat_use_case}
La classe ChatUseCase è un'interfaccia che definisce il caso d'uso della risposta ad una domanda dell'utente. Essa contiene un solo metodo, \texttt{get\_answer(question: Question): Answer}, che prende in input un oggetto di Business, Question, e restituisce un oggetto di Business, Answer. Questa interfaccia fa da attributo a ChatController e viene implementata da ChatService.


\subsubsubsection{Service}
\label{sec:service_backend}

\paragraph{ChatService}
\label{sec:chat_service}
La classe ChatService implementa l'interfaccia ChatUseCase e si occupa di eseguire la logica di business per la generazione di una risposta all'interrogazione di un utente.
Essa espone i seguenti tre metodi:
\begin{itemize}
    \item \texttt{get\_answer(question: Question): Answer}: Riceve in input un oggetto di Business, Question, e lo invia a SimilaritySearchService per la ricerca di similarità nel database vettoriale. Riceve in output i documenti rilevanti di tipo Document, li invia a GenerateAnswerService insieme all'input dell'utente, e infine restituisce la risposta di tipo Answer alla classe ChatController, di cui è attributo.
    \item \texttt{similarity\_search(user\_input: Question): Document*}: Riceve in input un oggetto di Business, Question, e lo invia a SimilaritySearchService per la ricerca di similarità nel database vettoriale. Restituisce i documenti rilevanti di tipo Document.
    \item \texttt{generate\_answer(user\_input: Question, relevant\_docs: Document*): Answer}: Riceve in input un oggetto di Business, Question, e i documenti rilevanti di tipo Document, e li invia a GenerateAnswerService per la generazione di una risposta. Restituisce la risposta di tipo Answer.
\end{itemize}

\paragraph{SimilaritySearchService}
\label{sec:similarity_search_service}
La classe SimilaritySearchService si occupa di eseguire la ricerca di \emph{similarità}\textsubscript{\textbf{\textit{G}}} nel database vettoriale. Essa espone un solo metodo, \texttt{similarity\_search(user\_input: Question): Document*}, che prende in input un oggetto di Business, Question, e chiama l'interfaccia SimilaritySearchPort per svolgere la ricerca di similarità in un database vettoriale. La porta restituisce una grande quantità di documenti rilevanti di tipo Document, i quali vengono sottoposti ad un filtraggio utilizzando un attributo di tipo DocumentConstraints (che possiede un attributo threshold e un attributo max\_gap), che impone che la distanza di similarità dei documenti dalla domanda rispetti un threshold, e impone che, se un documento è distante dal successivo elemento della lista di più del max\_gap, tutti i documenti successivi non passino il filtro. Infine, i documenti filtrati vengono restituiti al chiamante ChatService.

\paragraph{GenerateAnswerService}
\label{sec:generate_answer_service}
La classe GenerateAnswerService si occupa di generare una risposta all'interrogazione di un utente. Essa espone un solo metodo, \texttt{generate\_answer(user\_input: Question, relevant\_docs: Document*): Answer}, che prende in input un oggetto di Business, Question, e i documenti rilevanti di tipo Document, e ci associa l'oggetto di tipo Header presente come attributo, per poter così chiamare l'interfaccia GenerateAnswerPort allo scopo di generare una risposta. La risposta, di tipo Answer, viene restituita al chiamante ChatService. 


\subsubsubsection{Port}
\label{sec:port}

\paragraph{SimilaritySearchPort}
\label{sec:similarity_search_port}
L'interfaccia SimilaritySearchPort definisce l'interfaccia attraverso la quale SimilaritySearchService interagisce con il mondo esterno, permettendo il recupero di dati persistenti senza modificare la logica di business. Essa espone un solo metodo,\\ \texttt{similarity\_search(user\_input: Question): Document*}, che prende in input la domanda dell'utente di tipo Question, e si occupa di svolgere la ricerca di similarità in un \emph{database vettoriale}\textsubscript{\textbf{\textit{G}}} per ottenere una lista di documenti rilevanti di tipo Document. La porta viene implementata da ChromaVectorStoreAdapter.

\paragraph{GenerateAnswerPort}
\label{sec:generate_answer_port}
L'interfaccia GenerateAnswerPort definisce l'interfaccia attraverso la quale GenerateAnswerService interagisce con il mondo esterno, permettendo la generazione di dati da parte di un \emph{LLM}\textsubscript{\textbf{\textit{G}}} senza modificare la logica di business. Essa espone un solo metodo,\\ \texttt{generate\_answer(user\_input: Question, relevant\_docs: Document*, header: Header):\\ Answer}, che prende in input la domanda dell'utente di tipo Question, i documenti rilevanti di tipo Document, e un oggetto Header che fornisce il contesto introduttivo al chatbot, e si occupa di generare una risposta di tipo Answer. La porta viene implementata da LangChainAdapter.


\subsubsubsection{Adapter}
\label{sec:adapter}

\dots


\subsubsubsection{Repository}
\label{sec:repository}

\dots



\subsubsection{Frontend}
\label{sec:frontend}

\subsubsubsection{Component}
\label{sec:component}

\dots


\subsubsubsection{Service}
\label{sec:service_frontend}

\dots
