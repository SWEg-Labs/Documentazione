% Intestazione
\fancyhead[L]{1 \hspace{0.2cm} Architettura} % Testo a sinistra

\section{Architettura}
\label{sec:architettura}

Questa sezione fornisce una descrizione dettagliata dell'\emph{architettura logica}\textsubscript{\textbf{\textit{G}}} del prodotto software, illustrando le scelte progettuali adottate per garantire la corretta realizzazione del sistema. Saranno presentati le principali scelte e \emph{pattern architetturali}\textsubscript{\textbf{\textit{G}}}, e le \emph{componenti software}\textsubscript{\textbf{\textit{G}}} che compongono il sistema.

\subsection{Architettura logica}
L’architettura adottata nella realizzazione dell’applicativo si basa sul modello di \emph{architettura esagonale}\textsubscript{\textbf{\textit{G}}}. Il livello di \emph{business}\textsubscript{\textbf{\textit{G}}} del software è quindi indipendente dagli altri componenti, ovvero nulla presente all’esterno della logica di business può conoscere la sua \emph{implementazione}\textsubscript{\textbf{\textit{G}}}. Questo principio alla base dell’architettura esagonale ci permette di ottenere un prodotto software facilmente testabile e \emph{manutenibile}\textsubscript{\textbf{\textit{G}}}. Le componenti che devono restare indipendenti sono rappresentate dal \emph{Domain business model}\textsubscript{\textbf{\textit{G}}}, che non comunica mai direttamente con l’esterno.
Gli elementi che permettono il funzionamento dell’architettura esagonale sono i seguenti:
\begin{itemize}
    \item \textbf{\emph{Controller}}\textsubscript{\textbf{\textit{G}}}: contiene l'\emph{application logic}\textsubscript{\textbf{\textit{G}}} del sistema: gestisce le richieste in ingresso, valida i dati di tipo \emph{DTO}\textsubscript{\textbf{\textit{G}}} ricevuti in input, e li adatta verso un tipo di dato di business. Il \emph{Controller} ha poi il compito di chiamare uno \emph{UseCase} per eseguire la logica di business, adattare l'output ricevuto in un oggetto DTO e restituirlo al client.
    \item \textbf{\emph{UseCase}}\textsubscript{\textbf{\textit{G}}}: rappresenta un caso d'uso specifico del sistema, che viene implementato da un \emph{Service} per realizzare la logica di business.
    \item \textbf{\emph{Service}}\textsubscript{\textbf{\textit{G}}}: contiene la \emph{business logic}\textsubscript{\textbf{\textit{G}}} del sistema: esegue operazioni specifiche esclusive del dominio di interesse e delega le interazioni con le altre componenti ai \emph{Port}. I \emph{Service} possono interagire unicamente con tipi di dato di business, garantendo l'indipendenza della logica di business dal resto del sistema.
    \item \textbf{\emph{Port}}\textsubscript{\textbf{\textit{G}}}: definisce le interfacce attraverso le quali i \emph{Service} interagiscono con il mondo esterno, permettendo il salvataggio e recupero di dati persistenti senza modificare la logica di business.
    \item \textbf{\emph{Adapter}}\textsubscript{\textbf{\textit{G}}}: implementa una o più interfacce definite dai \emph{Port}, permettendo la comunicazione tra la logica di business e le tecnologie esterne di \emph{persistent logic}\textsubscript{\textbf{\textit{G}}}. L'\emph{adapter} si occupa di adattare i dati ricevuti dalla logica di business in un tipo \emph{Entity}\textsubscript{\textbf{\textit{G}}} adatto per la persistenza, e viceversa.
    \item \textbf{\emph{Repository}}\textsubscript{\textbf{\textit{G}}}: contiene la \emph{persistent logic} del sistema: gestisce la persistenza dei dati, interagendo con un database o altre forme di storage per salvare e/o recuperare le informazioni necessarie. I tipi di dato gestiti dal \emph{repository} sono gli \emph{Entity}, che rappresentano il livello intermedio che sta a contatto diretto con i dati persistenti del sistema.
\end{itemize}

È stato scelto di utilizzare un'architettura esagonale per i seguenti motivi:
\begin{itemize}
    \item \textbf{Facilità di test}: l'architettura esagonale permette di testare facilmente la business logic, in quanto è possibile sostituire gli adapter con degli \emph{stub}\textsubscript{\textbf{\textit{G}}} o dei \emph{mock}\textsubscript{\textbf{\textit{G}}};
    \item \textbf{\emph{Manutenibilità}}\textsubscript{\textbf{\textit{G}}}: l'architettura esagonale permette di mantenere la business logic indipendente dagli altri componenti, facilitando la manutenzione del codice;
    \item \textbf{\emph{Scalabilità}}\textsubscript{\textbf{\textit{G}}}: l'architettura esagonale permette di aggiungere nuovi adapter senza dover modificare la business logic.
\end{itemize}


\subsection{Architettura di Deployment}
\label{sec:architettura_deployment}

Per determinare l'\emph{architettura di deployment}\textsubscript{\textbf{\textit{G}}} più adatta all'applicativo, si è tenuto conto del contesto reale in cui verrà utilizzato. Poiché il sistema è destinato all'utilizzo in un'azienda, dove non si prevedono significative espansioni o modifiche strutturali dopo l'installazione, la scelta di un'architettura monolitica è risultata la più appropriata. Questa soluzione, oltre a essere perfettamente in linea con le esigenze del prodotto, semplifica le fasi di progettazione, sviluppo e test. Inoltre, rispetto a un'architettura a microservizi, la monolitica evita complessità che sarebbero state difficili da gestire, anche considerando le competenze attuali del team di sviluppo.\\\\
Il deployment del prodotto viene gestito attraverso la containerizzazione con \textbf{\emph{Docker Compose}}\textsubscript{\textbf{\textit{G}}}. Questa scelta consente di semplificare l’installazione dell’applicativo, fornendo un ambiente preconfigurato in cui tutte le dipendenze sono già risolte. In questo modo, vengono predisposti automaticamente tutti i servizi necessari per garantire il corretto funzionamento del sistema, riducendo le difficoltà legate alla configurazione manuale.



\subsection{Architettura di dettaglio}
\label{sec:architettura_di_dettaglio}

\subsubsection{Architettura della generazione di una risposta}
\label{sec:architettura_generazione_risposta}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura della generazione di una risposta}
\end{figure}

L'\emph{UML}\textsubscript{\textbf{\textit{G}}} in questione rappresenta l'\emph{architettura}\textsubscript{\textbf{\textit{G}}} della generazione di una risposta all'interrogazione di un utente, dal punto di vista del \emph{backend}\textsubscript{\textbf{\textit{G}}}.
Il \emph{frontend}\textsubscript{\textbf{\textit{G}}} invoca il metodo \texttt{chat} esposto dal \emph{backend}\textsubscript{\textbf{\textit{G}}} tramite \emph{FastAPI}\textsubscript{\textbf{\textit{G}}}, passando la domanda dell'utente in forma di dizionario.
La domanda viene recuperata dal ChatController, che converte la stringa interna al dizionario in un oggetto di Business, Question, e lo invia all'interfaccia ChatUseCase, implementata da ChatService.
ChatService, che implementa il \emph{Design Pattern} \emph{Facade}\textsubscript{\textbf{\textit{G}}}, chiama SimilaritySearchService, componente responsabile della ricerca di \emph{similarità}\textsubscript{\textbf{\textit{G}}} nel \emph{database vettoriale}\textsubscript{\textbf{\textit{G}}}, il quale si collega con SimilaritySearchPort verso l'esterno, sfruttando l'\emph{architettura esagonale}\textsubscript{\textbf{\textit{G}}}. La Porta viene implementata da ChromaVectorStoreAdapter, che adatta la Question verso un tipo stringa inviato a ChromaVectorStoreRepository, che gestisce il collegamento con il database vettoriale \emph{Chroma}\textsubscript{\textbf{\textit{G}}}, sul quale avviene la ricerca di similarità. Una volta ottenuti i risultati della ricerca e trasformati in \emph{Entity}\textsubscript{\textbf{\textit{G}}}, essi vengono convertiti nel tipo di Business Document e poi restituiti a ChatService, il quale dunque li invia assieme all'input dell'utente a GenerateAnswerService, classe di servizio munita di un attributo Header che consente di fornire un introduzione di contesto al chatbot. Header, input utente e documenti rilevanti vengono quindi forniti a LangChainAdapter, che si assicura che la somma dei \emph{token}\textsubscript{\textbf{\textit{G}}} dei parametri non superi la soglia limite per l'\emph{LLM}\textsubscript{\textbf{\textit{G}}} configurato. Infine, i parametri vengono forniti a LangChainRepository, che li combina assieme in unico prompt e, sfruttando gli strumenti forniti dalla libreria \emph{LangChain}\textsubscript{\textbf{\textit{G}}}, effettua una chiamata verso l'LLM di \emph{OpenAI}\textsubscript{\textbf{\textit{G}}} configurato per ottenere una risposta. 
La risposta viene quindi convertita in un oggetto Answer di \emph{Business Logic}\textsubscript{\textbf{\textit{G}}} ed infine convertita in stringa per essere inserita in un dizionario in ChatController, il quale restituisce la risposta al frontend.

\newpage


\subsubsection{Architettura dell'aggiornamento automatico del database vettoriale}
\label{sec:architettura_aggiornamento_database_vettoriale}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura dell'aggiornamento automatico del database vettoriale}
\end{figure}

L'UML in questione rappresenta l'architettura dell'aggiornamento automatico del \emph{database vettoriale}\textsubscript{\textbf{\textit{G}}}, il quale viene svolto da un \emph{cron}\textsubscript{\textbf{\textit{G}}} configurato periodicamente per eseguire un apposito script \emph{Python}\textsubscript{\textbf{\textit{G}}}. Il cron chiama l'apposito metodo della classe LoadFilesController, che a sua volta chiama l'interfaccia LoadFilesUseCase implementata da LoadFilesService.\\
LoadFilesService implementa il pattern \emph{Facade}\textsubscript{\textbf{\textit{G}}} per fornire un'unica interfaccia di collegamento alle piattaforme dalle quali caricare i file e alle piattaforme per il salvataggio degli stessi file e dei log di tutte le operazioni. In particolare, LoadFilesService si collega alle interfacce GitHubPort, JiraPort e ConfluencePort, che poi verranno implementate dai rispettivi adapter, che possiederanno i rispettivi repositories, rispettando l'\emph{Architettura Esagonale}\textsubscript{\textbf{\textit{G}}}. Vengono quindi recuperati i Commits e i Files da \emph{GitHub}\textsubscript{\textbf{\textit{G}}}, le Issues da \emph{Jira}\textsubscript{\textbf{\textit{G}}} e le pagine da \emph{Confluence}\textsubscript{\textbf{\textit{G}}}, estratti dagli account configurati, che vengono prima convertiti in \emph{Entity} nei repositories, e poi nel tipo di business Document mediante gli adapter. I documenti corrispondenti alle pagine di Confluence, una volta tornati a LoadFilesService, vengono appositamente trattati grazie all'attributo di tipo ConfluenceCleanerService di quest'ultima classe. La lista di oggetti Document viene dunque inviata a LoadFilesInVectorStorePort, implementata da ChromaVectorStoreAdapter, che si occupa di adattare i Document in DocumentEntity per poi inviarli a ChromaVectorStoreRepository, che si occupa di salvare i documenti nel database vettoriale \emph{Chroma}\textsubscript{\textbf{\textit{G}}}.\\
Ogni classe di repository, oltre a svolgere il proprio di compito, si occupa anche di creare e restituire uno specifico oggetto di log, di tipo PlatformLog per GitHUb, Jira e Confluence e di tipo VectorStoreLog per il database vettoriale, che vengono uniti assieme in un oggetto LoadingAttempt e poi inviati all'interfaccia SaveLoadingAttemptInDbPort, implementata da PostgresAdapter, che si occupa di adattare l'oggetto in PostgresLoadingAttempt e di inviarlo a PostgresRepository che lo salva nel \emph{database relazionale}\textsubscript{\textbf{\textit{G}}} \emph{Postgres}\textsubscript{\textbf{\textit{G}}}, per tenere traccia dell'esito di ogni tentativo di caricamento di documenti nel database vettoriale. Successivamente, lo stesso log, opportunamente formattato, viene salvato in un file di testo, situato dentro la cartella \texttt{src/backend}.

\newpage


\subsubsection{Architettura dell’inizializzazione, refresh e scroll di Angular}
\label{sec:architettura_inizializzazione_angular}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura dell’inizializzazione, refresh e scroll di Angular}
\end{figure}

\dots

\newpage


\subsubsection{Architettura dell’aggiornamento del rendering grafico durante la chat}
\label{sec:architettura_aggiornamento_rendering_chat}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura dell’aggiornamento del rendering grafico durante la chat}
\end{figure}

\dots

\newpage


\subsubsection{Architettura frontend dell’aggiornamento del badge di segnalazione dell’esito dell’ultimo aggiornamento automatico}
\label{sec:architettura_frontend_badge_aggiornamento}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura frontend dell’aggiornamento del badge di segnalazione dell’esito dell’ultimo aggiornamento automatico}
\end{figure}

\dots

\newpage


\subsubsection{Architettura backend dell’aggiornamento del badge di segnalazione dell’esito dell’ultimo aggiornamento automatico}
\label{sec:architettura_backend_badge_aggiornamento}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura backend dell’aggiornamento del badge di segnalazione dell’esito dell’ultimo aggiornamento automatico}
\end{figure}

L'UML in figura rappresenta l'architettura dell'aggiornamento del badge di segnalazione dell'esito dell'ultimo aggiornamento automatico, dal punto di vista del backend. Il frontend invoca il metodo\\ \texttt{get\_last\_load\_outcome} esposto dal backend tramite FastAPI, il quale chiama GetLastLoadOutcomeController, che a sua volta chiama l'interfaccia GetLastLoadOutcomeUseCase implementata da GetLastLoadOutcomeService. GetLastLoadOutcomeService chiama l'interfaccia GetLastLoadOutcomePort, implementata da PostgresAdapter, che invoca il metodo \texttt{get\_last\_load\_outcome} esposto da PostgresRepository, che si occupa di recuperare da Postgres l'ultimo esito del caricamento di documenti nel database vettoriale Chroma. Più precisamente, viene recuperato l'attributo \texttt{outcome} della tupla con timestamp di fine aggiornamento più recente dalla tabella \texttt{loading\_attempts}. PostgresRepository restituisce un oggetto di tipo PostgresLastLoadOutcome, che può assumere valore True, se l'ultimo tentativo di aggiornamento ha avuto esito positivo, False, se l'ultimo tentativo di aggiornamento ha avuto esito negativo, o Error, se c'è stato un errore nell'interazione con Postgres per recuperare l'esito dell'ultimo aggiornamento. L'oggetto PostgresLastLoadOutcome viene convertito in un oggetto di tipo LastLoadOutcome da PostgresAdapter e restituito a GetLastLoadOutcomeService. Infine, GetLastLoadOutcomeController converte l'oggetto verso il tipo LastLoadOutcomeDTO e lo restituisce al frontend.

\newpage


\subsubsection{Architettura del salvataggio dei messaggi nello storico}
\label{sec:architettura_salvataggio_messaggi_storico}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura del salvataggio dei messaggi nello storico}
\end{figure}

L'\emph{UML} in figura rappresenta l'\emph{architettura} del salvataggio dei messaggi nello storico.
Il \emph{frontend} invoca il metodo \texttt{save\_message} esposto dal \emph{backend} tramite \emph{FastAPI}, passando il messaggio in forma di MessageDTO.
Il messaggio viene recuperato dal SaveMessageController, che converte il messaggio in un oggetto di Business, Message, e lo invia all'\emph{interfaccia}\textsubscript{\textbf{\textit{G}}} SaveMessageUseCase, implementata da SaveMessageService.
SaveMessageService, quindi, chiama l'interfaccia SaveMessagePort, che è implementata da PostgresAdapter.
PostgresAdapter si occupa di convertire il tipo di dato Message nel tipo PostgresMessage, e invoca il metodo \texttt{save\_message} esposto dalla classe PostgresRepository.
PostgresRepository gestisce il collegamento con il \emph{database relazionale}\textsubscript{\textbf{\textit{G}}} \emph{Postgres}\textsubscript{\textbf{\textit{G}}},
esegue l'operazione di salvataggio del messaggio sul database e restituisce un oggetto di tipo PostgresSaveOperationResponse che indica il successo o fallimento dell'operazione di salvataggio e la descrizione del successo o dell'eventuale errore.
Successivamente PostgresAdapter si occupa anche di convertire l'oggetto PostgresSaveOperationResponse in un DbSaveOperationResponse corrispondente e lo restituisce a SaveMessageService.
Infine SaveMessageController riceve la DbSaveOperationResponse e la converte in un dizionario da restituire a frontend, che gestirà appositamente il successo o l'errore.

\newpage


\subsubsection{Architettura del recupero dei messaggi dallo storico}
\label{sec:architettura_recupero_messaggi_storico}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura del recupero dei messaggi dallo storico}
\end{figure}

L'UML in figura rappresenta l'architettura del recupero dei messaggi nello storico.
Il frontend invoca il metodo \texttt{get\_messages} esposto dal backend tramite FastAPI, passando come parametro un dizionario che indica la quantità di messaggi da ottenere.
Il metodo \texttt{get\_messages} chiama GetMessagesController, che converte il dizionario in un oggetto Quantity e lo passa all'interfaccia GetMessagesUseCase, implementata da GetMessagesService.
GetMessagesService, quindi, chiama l'interfaccia GetMessagesPort, che è implementata da PostgresAdapter.
PostgresAdapter converte l'oggetto Quantity in un intero da passare come parametro alla classe PostgresRepository, che gestisce il collegamento con il database relazionale Postgres. 
PostgresRepository esegue l’operazione di recupero della quantità di messaggi richiesti e restituisce una lista di messaggi di tipo PostgresMessage.
Allora PostgresAdapter si occupa di convertirla in una lista di oggetti Message, che viene restituita all'indietro a GetMessagesService.
Infine GetMessagesController riceve una lista di Message e la usa per creare una lista di MessageDTO che restituisce al frontend.

\newpage


\subsubsection{Architettura della generazione di domande per proseguire la conversazione}
\label{sec:architettura_generazione_domande_conversazione}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura della generazione di domande per proseguire la conversazione}
\end{figure}

L'UML in figura rappresenta l'architettura della generazione di domande per proseguire la conversazione.
Il frontend invoca il metodo \texttt{get\_next\_possible\_questions} esposto dal backend tramite FastAPI, passando come parametro un dizionario che contiene l'ultima domanda dell'utente, l'ultima risposta del chatbot e la quantità di domande da ottenere.
Il metodo \texttt{get\_next\_possible\_questions} chiama GetNextPossibleQuestionsController, che converte il dizionario in un oggetto QuestionAnswerCouple contenente domanda (di tipo Question) e risposta (di tipo Answer) e in un oggetto Quantity contenente la quantità richiesta, e lo passa all'interfaccia GetNextPossibleQuestionsUseCase, implementata da GetNextPossibleQuestionsService.
GetNextPossibleQuestionsService possiede un attributo di tipo Header contenente un'introduzione di contesto per l'\emph{LLM}\textsubscript{\textbf{\textit{G}}}, templatizzata sulla base del numero di domande da richiedere, che a questo punto viene stabilito in base al parametro Quantity. L'attributo di tipo Header contiene anche importanti istruzioni di sintassi che l'\emph{LLM} deve rispettare, cioè impone che le possibili domande generate sia l'unico contenuto del messaggio e siano separate da \_\_. La classe GetNextPossibleQuestionsService chiama dunque l'interfaccia GetNextPossibleQuestionsPort con parametri QuestionAnswerCouple ed Header.
L'interfaccia è implementata da LangChainAdapter, che si occupa di adattare i parametri da QuestionAnswerCouple ed Header a due tipi stringa, per poi inviarli a LangChainRepository, che si occupa di invocare l'\emph{LLM} configurato per ottenere le possibili domande successive, in forma di un'unica stringa. Quest'ultima nell'Adapter viene suddivisa in 3 oggetti PossibleQuestion, sfruttando il fatto che l'header ha imposto all'LLM che le domande siano separate da \_\_, e, insieme ad un intero num\_questions che indica il numero di domande, vengono poi riunite in un oggetto NextPossibleQuestions, per essere quindi restituite a GetNextPossibleQuestionsService.
Infine GetNextPossibleQuestionsController riceve l'oggetto NextPossibleQuestions, converte le domande contenute in un dizionario di stringhe, e lo restituisce al frontend.

\newpage



\subsection{Design pattern utilizzati}
\label{sec:design_pattern_utilizzati}


\subsubsection{Facade}
\label{sec:facade}

Il pattern \emph{Facade}\textsubscript{\textbf{\textit{G}}} è stato adottato per permettere al \emph{cron}\textsubscript{\textbf{\textit{G}}} di accedere ad unica classe LoadFilesService avente il compito di caricare tutti i tipi di file necessari per l'aggiornamento del database vettoriale. Questo pattern permette di nascondere la complessità del sistema, fornendo un'interfaccia semplificata per l'accesso alle funzionalità offerte dalla classe LoadFilesService. In questo modo, il cron non deve preoccuparsi di come i file vengono caricati, ma può semplicemente chiamare il metodo \texttt{load} della suddetta classe per ottenere il risultato desiderato.
E' stato inoltre adottato un piccolo Facade anche per l'architettura di generazione di una risposta, dove ChatService si occupa di nascondere la complessità della logica di business, fornendo un'interfaccia semplificata per l'accesso alle funzionalità offerte da SimilaritySearchService e GenerateAnswerService.
Grazie a questo pattern, è possibile mantenere il codice più pulito e manutenibile, in quanto la complessità è nascosta all'esterno e le interazioni con le classi interne sono semplificate.


\subsubsection{Dependency Injection}
\label{sec:dependency_injection}

Il pattern \emph{Dependency Injection}\textsubscript{\textbf{\textit{G}}} è stato adottato per permettere l'iniezione delle dipendenze all'interno delle classi del sistema. Questo pattern permette di separare la creazione degli oggetti dal loro utilizzo, semplificando la gestione delle dipendenze e rendendo il codice più manutenibile e testabile. In questo modo, le classi non devono preoccuparsi di come vengono creati gli oggetti di cui hanno bisogno, ma possono semplicemente riceverli come parametri di costruzione. Questo permette di sostituire facilmente le implementazioni delle dipendenze, senza dover modificare il codice di tutte le classi che le utilizzano. Inoltre, grazie all'utilizzo di un \emph{framework}\textsubscript{\textbf{\textit{G}}} di \emph{Dependency Injection}, come \emph{Angular}\textsubscript{\textbf{\textit{G}}}, è possibile automatizzare il processo di creazione e iniezione delle dipendenze, semplificando ulteriormente lo sviluppo del \emph{frontend}\textsubscript{\textbf{\textit{G}}}. Il pattern è stato implementato anche in \emph{Python}\textsubscript{\textbf{\textit{G}}} nel \emph{backend}\textsubscript{\textbf{\textit{G}}}, attraverso due funzioni, \texttt{dependency\_injection\_frontend} e \texttt{dependenc\_injection\_cron}, che si occupano di iniettare le dipendenze rispettivamente nel file di endpoint \emph{FastAPI}\textsubscript{\textbf{\textit{G}}} a cui accede il frontend per contattare il backend e nel file che viene eseguito periodicamente dal cron per l'aggiornamento del \emph{database vettoriale}\textsubscript{\textbf{\textit{G}}}.


\subsubsection{MVVM}
\label{sec:mvvm}

Il pattern \emph{MVVM}\textsubscript{\textbf{\textit{G}}} è stato adottato per la progettazione dell'architettura del \emph{frontend}, in particolare per separare la logica di presentazione dalla logica di business, semplificando la gestione delle interazioni tra i componenti dell'applicazione. Nello specifico, il \emph{Model}\textsubscript{\textbf{\textit{G}}} rappresenta i dati e la logica di business dell'applicazione, il \emph{View}\textsubscript{\textbf{\textit{G}}} si occupa della presentazione dei dati all'utente, e il \emph{ViewModel}\textsubscript{\textbf{\textit{G}}} si occupa di gestire la logica di presentazione e di coordinare le interazioni tra il \emph{Model} e la \emph{View}. Questo permette di mantenere il codice più pulito e manutenibile, in quanto la logica di business è separata dalla logica di presentazione, e le interazioni tra i componenti sono semplificate. Inoltre, grazie all'utilizzo di un \emph{framework} come \emph{Angular}, è possibile automatizzare il processo di creazione e gestione dei componenti, semplificando ulteriormente lo sviluppo del \emph{frontend}. Il pattern è stato implementato in \emph{Angular} attraverso la creazione di componenti per la \emph{View} e il \emph{ViewModel}, e la creazione di servizi per la gestione della logica di business del \emph{Model}.

\newpage



\subsection{Descrizione delle classi}
\label{sec:descrizione_classi}

\subsubsection{Backend}
\label{sec:backend}

\subsubsubsection{Controller}
\label{sec:controller}

\paragraph{ChatController}
\label{sec:chat_controller}
La classe ChatController si occupa di mettere in contatto il frontend con il backend nell'architettura di generazione di una risposta. Attraverso il metodo \texttt{get\_answer(user\_input: Request): dict[string, string]}, riceve il messaggio dell'utente di tipo Request, dal quale ricava un dizionario, che poi converte in un oggetto di Business, Question, e lo invia all'interfaccia ChatUseCase. Riceve poi da essa in output un oggetto Answer, lo converte in stringa, lo inserisce in un dizionario e infine lo restituisce al frontend.

\paragraph{LoadFilesController}
\label{sec:load_files_controller}
La classe LoadFilesController si occupa di mettere in contatto il cron con il backend nell'architettura dell'aggiornamento automatico del database vettoriale. Attraverso il metodo \texttt{load()}, invia una richiesta all'interfaccia LoadFilesUseCase per il caricamento dei file da \emph{GitHub}\textsubscript{\textbf{\textit{G}}}, \emph{Jira}\textsubscript{\textbf{\textit{G}}} e \emph{Confluence}\textsubscript{\textbf{\textit{G}}} verso \emph{Chroma}\textsubscript{\textbf{\textit{G}}}, e il salvataggio dei rispettivi log in \emph{Postgres}\textsubscript{\textbf{\textit{G}}} e in un file di testo.

\paragraph{GetMessagesController}
\label{sec:get_messages_controller}
La classe GetMessagesController si occupa di mettere in contatto il frontend con il backend nell'architettura del recupero dei messaggi dallo storico. Attraverso il metodo \texttt{get\_messages(quantity: dict[string, int]): MessageDTO*}, riceve un dizionario che indica la quantità di messaggi da recuperare, lo converte in un oggetto Quantity, e lo invia all'interfaccia GetMessagesUseCase. Riceve poi da essa in output una lista di messaggi, la converte in una lista di MessageDTO e la restituisce al frontend.

\paragraph{SaveMessageController}
\label{sec:save_message_controller}
La classe SaveMessageController si occupa di mettere in contatto il frontend con il backend nell'architettura del salvataggio dei messaggi nello storico. Attraverso il metodo \texttt{save(message: MessageDTO): dict[string, bool | string]}, riceve il messaggio dell'utente di tipo MessageDTO, lo converte in un oggetto di Business, Message, e lo invia all'interfaccia SaveMessageUseCase. Riceve poi da essa in output un DbSaveOperationResponse, lo converte in un dizionario e lo restituisce al frontend.

\paragraph{GetNextPossibleQuestionsController}
\label{sec:get_next_possible_questions_controller}
La classe GetNextPossibleQuestionsController si occupa di mettere in contatto il frontend con il backend nell'architettura della generazione di domande per proseguire la conversazione. Attraverso il metodo \texttt{get\_next\_possible\_questions\\(question\_answer\_quantity: dict[string, string | int]): dict[string,\\ string]}, riceve un dizionario che contiene l'ultima domanda dell'utente, l'ultima risposta del chatbot e un intero che indica il numero di domande da generare, li converte in un oggetto QuestionAnswerCouple (contenente un oggetto Question e un oggetto Answer) e un oggetto Quantity, e li invia all'interfaccia GetNextPossibleQuestionsUseCase. Riceve poi da essa in output un oggetto NextPossibleQuestions, converte le domande contenute in un dizionario di stringhe, e lo restituisce al frontend.

\paragraph{GetLastLoadOutcomeController}
\label{sec:get_last_load_outcome_controller}
La classe GetLastLoadOutcomeController si occupa di mettere in contatto il frontend con il backend nell'architettura dell'aggiornamento del badge di segnalazione dell'esito dell'ultimo aggiornamento automatico. Attraverso il metodo \texttt{get\_last\_load\_outcome(): LastLoadOutcomeDTO}, invia una richiesta all'interfaccia GetLastLoadOutcomeUseCase per ottenere l'esito dell'ultimo aggiornamento del database vettoriale, converte l'oggetto LastLoadOutcome ottenuto in un oggetto LastLoadOutcomeDTO e lo restituisce al frontend.

\newpage


\subsubsubsection{Use Case}
\label{sec:use_case}

\paragraph{ChatUseCase}
\label{sec:chat_use_case}
ChatUseCase è un'interfaccia che definisce il caso d'uso della risposta ad una domanda dell'utente. Essa contiene un solo metodo, \texttt{get\_answer(question: Question): Answer}, che prende in input una domanda, Question, e restituisce una risposta, Answer. Questa interfaccia fa da attributo a ChatController e viene implementata da ChatService.

\paragraph{LoadFilesUseCase}
\label{sec:load_files_use_case}
LoadFilesUseCase è un'interfaccia che definisce il caso d'uso dell'aggiornamento automatico del database vettoriale. Essa contiene un solo metodo, \texttt{load()}, la cui implementazione avvia il caricamento dei dati. Questa interfaccia fa da attributo a LoadFilesController e viene implementata da LoadFilesService.

\paragraph{GetMessagesUseCase}
\label{sec:get_messages_use_case}
GetMessagesUseCase è un'interfaccia che definisce il caso d'uso del recupero dei messaggi dallo storico. Essa contiene un solo metodo, \texttt{get\_messages(quantity: Quantity): Message*}, che prende in input la quantità dei messaggi da recuperare, Quantity, e restituisce una lista di messaggi di tipo Message. Questa interfaccia fa da attributo a GetMessagesController e viene implementata da GetMessagesService.

\paragraph{SaveMessageUseCase}
\label{sec:save_message_use_case}
SaveMessageUseCase è un'interfaccia che definisce il caso d'uso del salvataggio dei messaggi nello storico. Essa contiene un solo metodo, \texttt{save(message: Message): DbSaveOperationResponse}, che prende in input un messaggio, Message, e restituisce una risposta dal database, DbSaveOperationResponse. Questa interfaccia fa da attributo a SaveMessageController e viene implementata da SaveMessageService.

\paragraph{GetNextPossibleQuestionsUseCase}
\label{sec:get_next_possible_questions_use_case}
GetNextPossibleQuestionsUseCase è un'interfaccia che definisce il caso d'uso della generazione di domande per proseguire la conversazione. Essa contiene un solo metodo, \texttt{get\_next\_possible\_questions(question\_answer\_couple: QuestionAnswerCouple, quantity: Quantity): NextPossibleQuestions}, che prende in input una coppia domanda-risposta, QuestionAnswerCouple, e un oggetto di tipo Quantity contenente un intero che indica il numero di domande da generare, e restituisce le possibili domande successive, NextPossibleQuestions. Questa interfaccia fa da attributo a GetNextPossibleQuestionsController e viene implementata da GetNextPossibleQuestionsService.

\paragraph{GetLastLoadOutcomeUseCase}
\label{sec:get_last_load_outcome_use_case}
GetLastLoadOutcomeUseCase è un'interfaccia che definisce il caso d'uso dell'aggiornamento del badge di segnalazione dell'esito dell'ultimo aggiornamento automatico. Essa contiene un solo metodo, \texttt{get\_last\_load\_outcome(): LastLoadOutcome}, che restituisce l'esito dell'ultimo aggiornamento del database vettoriale, di tipo LastLoadOutcome. Questa interfaccia fa da attributo a GetLastLoadOutcomeController e viene implementata da GetLastLoadOutcomeService.

\newpage


\subsubsubsection{Service}
\label{sec:service_backend}

\paragraph{ChatService}
\label{sec:chat_service}
La classe ChatService implementa l'interfaccia ChatUseCase e si occupa di eseguire la logica di business per la generazione di una risposta all'interrogazione di un utente.
Essa espone i seguenti tre metodi:
\begin{itemize}
    \item \texttt{get\_answer(question: Question): Answer}: Riceve in input un oggetto di Business, Question, e lo invia a SimilaritySearchService per la ricerca di similarità nel database vettoriale. Riceve in output i documenti rilevanti di tipo Document, li invia a GenerateAnswerService insieme all'input dell'utente, e infine restituisce la risposta di tipo Answer alla classe ChatController, di cui è attributo;
    \item \texttt{similarity\_search(user\_input: Question): Document*}: Riceve in input un oggetto di Business, Question, e lo invia a SimilaritySearchService per la ricerca di similarità nel database vettoriale. Restituisce i documenti rilevanti di tipo Document;
    \item \texttt{generate\_answer(user\_input: Question, relevant\_docs: Document*): Answer}: Riceve in input un oggetto di Business, Question, e i documenti rilevanti di tipo Document, e li invia a GenerateAnswerService per la generazione di una risposta. Restituisce la risposta di tipo Answer.
\end{itemize}

\paragraph{SimilaritySearchService}
\label{sec:similarity_search_service}
La classe SimilaritySearchService si occupa di eseguire la ricerca di \emph{similarità}\textsubscript{\textbf{\textit{G}}} nel database vettoriale. Essa espone un solo metodo, \texttt{similarity\_search(user\_input: Question): Document*}, che prende in input un oggetto di Business, Question, e chiama l'interfaccia SimilaritySearchPort per svolgere la ricerca di similarità in un database vettoriale. La porta restituisce una grande quantità di documenti rilevanti di tipo Document, i quali vengono sottoposti ad un filtraggio utilizzando un attributo di tipo DocumentConstraints (che possiede un attributo threshold e un attributo max\_gap), che impone che la distanza di similarità dei documenti dalla domanda rispetti un threshold, e impone che, se un documento è distante dal successivo elemento della lista di più del max\_gap, tutti i documenti successivi non passino il filtro. Infine, i documenti filtrati vengono restituiti a ChatService.

\paragraph{GenerateAnswerService}
\label{sec:generate_answer_service}
La classe GenerateAnswerService si occupa di generare una risposta all'interrogazione di un utente. Essa espone un solo metodo, \texttt{generate\_answer(user\_input: Question, relevant\_docs: Document*): Answer}, che prende in input un oggetto di Business, Question, e i documenti rilevanti di tipo Document, e ci associa l'oggetto di tipo Header presente come attributo, per poter così chiamare l'interfaccia GenerateAnswerPort allo scopo di generare una risposta. La risposta, di tipo Answer, viene restituita a ChatService.

\paragraph{LoadFilesService}
\label{sec:load_files_service}
La classe LoadFilesService implementa l'interfaccia LoadFilesUseCase e si occupa di eseguire la logica di business per l'aggiornamento automatico del database vettoriale. Essa implementa il \emph{design pattern}\textsubscript{\textbf{\textit{G}}} \emph{Facade}\textsubscript{\textbf{\textit{G}}}, ed espone i seguenti metodi:
\begin{itemize}
    \item \texttt{load()}: Si occupa di chiamare i metodi di estrazione dei file da GitHub, Jira e Confluence, di pulizia delle pagine Confluence, di caricamento in Chroma e di salvataggio dei log in Postgres e in un file di testo;
    \item \texttt{load\_github\_commits(): (PlatformLog, Document*)}: Si occupa di recuperare i Commits da GitHub e di salvare i rispettivi log. Restituisce una tupla contenente un oggetto di tipo PlatformLog, corrispondente al log, e una lista di oggetti di tipo Document, corrispondenti ai commits;
    \item \texttt{load\_github\_files(): (PlatformLog, Document*)}: Si occupa di recuperare i Files da GitHub e di salvare i rispettivi log. Restituisce una tupla contenente un oggetto di tipo PlatformLog, corrispondente al log, e una lista di oggetti di tipo Document, corrispondenti ai files;
    \item \texttt{load\_jira\_issues(): (PlatformLog, Document*)}: Si occupa di recuperare le Issues da Jira e di salvare i rispettivi log. Restituisce una tupla contenente un oggetto di tipo PlatformLog, corrispondente al log, e una lista di oggetti di tipo Document, corrispondenti alle issues;
    \item \texttt{load\_confluence\_pages(): (PlatformLog, Document*)}: Si occupa di recuperare le Pagine da Confluence e di salvare i rispettivi log. Restituisce una tupla contenente un oggetto di tipo PlatformLog, corrispondente al log, e una lista di oggetti di tipo Document, corrispondenti alle pagine;
    \item \texttt{clean\_confluence\_pages(pages: Document*): Document*}: Si occupa di pulire le pagine di Confluence, rimuovendo i tag HTML e i caratteri speciali. Restituisce la lista di pagine pulite, sempre di tipo Document;
    \item \texttt{load\_in\_vector\_store(documents: Document*): VectorStoreLog}: Si occupa di caricare i documenti nel database vettoriale Chroma e di salvare i rispettivi log. Restituisce un oggetto di tipo VectorStoreLog, corrispondente al log del caricamento;
    \item \texttt{save\_loading\_attempt\_in\_db(loading\_attempt: LoadingAttempt):\\ DbSaveOperationResponse}: Si occupa di salvare l'esito del caricamento dei documenti nel database relazionale Postgres. Restituisce un oggetto di tipo DbSaveOperationResponse, corrispondente alla risposta del database;
    \item \texttt{save\_loading\_attempt\_in\_txt(loading\_attempt: LoadingAttempt)}: Si occupa di salvare l'esito del caricamento dei documenti in un file di testo, sfruttando la libreria \texttt{logging} di \emph{Python}\textsubscript{\textbf{\textit{G}}}.
\end{itemize}

\paragraph{ConfluenceCleanerService}
\label{sec:confluence_cleaner_service}
La classe ConfluenceCleanerService si occupa di pulire le pagine di Confluence, rimuovendo i tag HTML e i caratteri speciali. Essa espone il seguente metodo pubblico:
\begin{itemize}
    \item \texttt{clean\_confluence\_pages(pages: Document*): Document*}: Si occupa di pulire le pagine di Confluence, rimuovendo i tag HTML e i caratteri speciali. Restituisce la lista di pagine pulite, sempre di tipo Document.
\end{itemize}
Inoltre, contiene i seguenti metodi privati:
\begin{itemize}
    \item \texttt{remove\_html\_tags(document: Document): Document}: Si occupa di rimuovere i tag HTML da una pagina di Confluence. Restituisce la pagina pulita, di tipo Document;
    \item \texttt{replace\_html\_entities(document: Document): Document}: Si occupa di sostituire le entità HTML con i corrispondenti caratteri Unicode da una pagina di Confluence. Restituisce la pagina pulita, di tipo Document.
\end{itemize}

\paragraph{GetMessagesService}
\label{sec:get_messages_service}
La classe GetMessagesService implementa l'interfaccia GetMessagesUseCase e si occupa di eseguire la logica di business per il recupero dei messaggi dallo storico. Essa espone un solo metodo, \texttt{get\_messages(quantity: Quantity): Message*}, che prende in input un oggetto di Business, Quantity, e chiama l'interfaccia GetMessagesPort per recuperare la quantità di messaggi richiesta. La porta restituisce una lista di messaggi, che vengono a loro volta restituiti a GetMessagesController.

\paragraph{SaveMessageService}
\label{sec:save_message_service}
La classe SaveMessageService implementa l'interfaccia SaveMessageUseCase e si occupa di eseguire la logica di business per il salvataggio dei messaggi nello storico. Essa espone un solo metodo, \texttt{save(message: Message): DbSaveOperationResponse}, che prende in input un oggetto di Business, Message, e chiama l'interfaccia SaveMessagePort per salvare il messaggio sul database. La porta restituisce un oggetto di Business, DbSaveOperationResponse, che viene a sua volta restituito a SaveMessageController.

\paragraph{GetNextPossibleQuestionsService}
\label{sec:get_next_possible_questions_service}
La classe GetNextPossibleQuestionsService implementa l'interfaccia GetNextPossibleQuestionsUseCase e si occupa di eseguire la logica di business per la generazione di domande per proseguire la conversazione. Essa espone un solo metodo,\\ \texttt{get\_next\_possible\_questions(question\_answer\_couple: QuestionAnswerCouple, quantity:\\ Quantity): NextPossibleQuestions}, che prende in input una coppia domanda-risposta, QuestionAnswerCouple, e un oggetto di tipo Quantity contenente un intero che indica il numero di domande da generare, e chiama l'interfaccia GetNextPossibleQuestionsPort per generare le possibili domande successive. La porta restituisce le possibili domande racchiuse in un oggetto di Business, NextPossibleQuestions, che viene a sua volta restituito a GetNextPossibleQuestionsController.
Inoltre questa classe possiede un attributo privato di tipo Header, che contiene un'introduzione per dare contesto al chatbot, e viene passato a GetNextPossibleQuestionsPort quando viene chiamato.

\paragraph{GetLastLoadOutcomeService}
\label{sec:get_last_load_outcome_service}
La classe GetLastLoadOutcomeService implementa l'interfaccia GetLastLoadOutcomeUseCase e si occupa di eseguire la logica di business per l'aggiornamento del badge di segnalazione dell'esito dell'ultimo aggiornamento automatico. Essa espone un solo metodo, \texttt{get\_last\_load\_outcome(): LastLoadOutcome}, che chiama l'interfaccia GetLastLoadOutcomePort per ottenere l'esito dell'ultimo aggiornamento del database vettoriale. La porta restituisce un oggetto di Business, LastLoadOutcome, che viene a sua volta restituito a GetLastLoadOutcomeController.

\newpage


\subsubsubsection{Port}
\label{sec:port}

\paragraph{SimilaritySearchPort}
\label{sec:similarity_search_port}
SimilaritySearchPort definisce l'interfaccia attraverso la quale SimilaritySearchService interagisce con il mondo esterno, permettendo il recupero di dati persistenti senza modificare la logica di business. Essa espone un solo metodo,\\ \texttt{similarity\_search(user\_input: Question): Document*}, che prende in input la domanda dell'utente di tipo Question, e si occupa di svolgere la ricerca di similarità in un \emph{database vettoriale}\textsubscript{\textbf{\textit{G}}} per ottenere una lista di documenti rilevanti di tipo Document. La porta viene implementata da ChromaVectorStoreAdapter.

\paragraph{GenerateAnswerPort}
\label{sec:generate_answer_port}
GenerateAnswerPort definisce l'interfaccia attraverso la quale GenerateAnswerService interagisce con il mondo esterno, permettendo la generazione di dati da parte di un \emph{LLM}\textsubscript{\textbf{\textit{G}}} senza modificare la logica di business. Essa espone un solo metodo,\\ \texttt{generate\_answer(user\_input: Question, relevant\_docs: Document*, header: Header):\\ Answer}, che prende in input la domanda dell'utente di tipo Question, i documenti rilevanti di tipo Document, e un oggetto Header che fornisce il contesto introduttivo al chatbot, e si occupa di generare una risposta di tipo Answer. La porta viene implementata da LangChainAdapter.

\paragraph{GitHubPort}
\label{sec:github_port}
GitHubPort definisce una delle interfacce attraverso le quali LoadFilesService interagisce con il mondo esterno, permettendo il recupero di dati persistenti senza modificare la logica di business. Essa espone due metodi:
\begin{itemize}
    \item \texttt{load\_github\_commits(): (PlatformLog, Document*)}: Si occupa di recuperare i Commits da GitHub e di salvare i rispettivi log. Restituisce una tupla contenente un oggetto di tipo PlatformLog, corrispondente al log, e una lista di oggetti di tipo Document, corrispondenti ai commits;
    \item \texttt{load\_github\_files(): (PlatformLog, Document*)}: Si occupa di recuperare i Files da GitHub e di salvare i rispettivi log. Restituisce una tupla contenente un oggetto di tipo PlatformLog, corrispondente al log, e una lista di oggetti di tipo Document, corrispondenti ai files.
\end{itemize}
La porta viene implementata da GitHubAdapter.

\paragraph{JiraPort}
\label{sec:jira_port}
JiraPort definisce una delle interfacce attraverso le quali LoadFilesService interagisce con il mondo esterno, permettendo il recupero di dati persistenti senza modificare la logica di business. Essa espone un solo metodo, \texttt{load\_jira\_issues(): (PlatformLog, Document*)}, che si occupa di recuperare le Issues da Jira e di salvare i rispettivi log. Restituisce una tupla contenente un oggetto di tipo PlatformLog, corrispondente al log, e una lista di oggetti di tipo Document, corrispondenti alle issues. La porta viene implementata da JiraAdapter.

\paragraph{ConfluencePort}
\label{sec:confluence_port}
ConfluencePort definisce una delle interfacce attraverso le quali LoadFilesService interagisce con il mondo esterno, permettendo il recupero di dati persistenti senza modificare la logica di business. Essa espone un solo metodo, \texttt{load\_confluence\_pages(): (PlatformLog, Document*)}, che si occupa di recuperare le Pagine da Confluence e di salvare i rispettivi log. Restituisce una tupla contenente un oggetto di tipo PlatformLog, corrispondente al log, e una lista di oggetti di tipo Document, corrispondenti alle pagine. La porta viene implementata da ConfluenceAdapter.

\paragraph{LoadFilesInVectorStorePort}
\label{sec:load_files_in_vector_store_port}
LoadFilesInVectorStorePort definisce una\\ delle interfacce attraverso le quali LoadFilesService interagisce con il mondo esterno, permettendo il caricamento dei documenti nel database vettoriale senza modificare la logica di business. Essa espone un solo metodo, \texttt{load(documents: Document*): VectorStoreLog}, che prende in input una lista di documenti di tipo Document, e si occupa di caricare i documenti nel database vettoriale configurato e di restituito il corrispondente log, di tipo VectorStoreLog. La porta viene implementata da ChromaVectorStoreAdapter.

\paragraph{SaveLoadingAttemptInDbPort}
\label{sec:save_loading_attempt_in_db_port}
SaveLoadingAttemptInDbPort definisce una delle interfacce attraverso le quali LoadFilesService interagisce con il mondo esterno, permettendo il salvataggio di dati persistenti senza modificare la logica di business. Essa espone un solo metodo,\\ \texttt{save\_loading\_attempt(loading\_attempt: LoadingAttempt): DbSaveOperationResponse}, che prende in input l'esito del caricamento, LoadingAttempt, e si occupa di salvarlo nel database relazionale configurato e di restituire la corrispondente risposta, di tipo DbSaveOperationResponse. La porta viene implementata da PostgresAdapter.

\paragraph{GetMessagesPort}
\label{sec:get_messages_port}
GetMessagesPort definisce l'interfaccia attraverso la quale GetMessagesService interagisce con il mondo esterno, permettendo il recupero di dati persistenti senza modificare la logica di business. Essa espone un solo metodo, \texttt{get\_messages(quantity: Quantity):\\ Message*}, che prende in input la quantità di messaggi da recuperare di tipo Quantity, e si occupa di recuperare i messaggi da un database, di tipo Message. La porta viene implementata da PostgresAdapter.

\paragraph{SaveMessagePort}
\label{sec:save_message_port}
SaveMessagePort definisce l'interfaccia attraverso la quale SaveMessageService interagisce con il mondo esterno, permettendo il salvataggio di dati persistenti senza modificare la logica di business. Essa espone un solo metodo, \texttt{save(message: Message):\\ DbSaveOperationResponse}, che prende in input il messaggio da salvare di tipo Message, e si occupa di salvare il messaggio in un database e riportare la sua risposta, di tipo DbSaveOperationResponse. La porta viene implementata da PostgresAdapter.

\paragraph{GetNextPossibleQuestionsPort}
\label{sec:get_next_possible_questions_port}
GetNextPossibleQuestionsPort definisce l'interfaccia attraverso la quale GetNextPossibleQuestionsService interagisce con il mondo esterno, permettendo la generazione di possibili domande successive senza modificare la logica di business. Essa espone un solo metodo, \texttt{get\_next\_possible\_questions(question\_answer\_couple: QuestionAnswerCouple, header:\\ Header): NextPossibleQuestions}, che prende in input una coppia domanda-risposta, QuestionAnswerCouple, e un'introduzione per dare contesto al chatbot, Header, e si occupa di generare le possibili domande successive, di tipo NextPossibleQuestions. La porta viene implementata da LangChainAdapter.

\paragraph{GetLastLoadOutcomePort}
\label{sec:get_last_load_outcome_port}
GetLastLoadOutcomePort definisce l'interfaccia attraverso la quale GetLastLoadOutcomeService interagisce con il mondo esterno, permettendo il recupero di dati persistenti senza modificare la logica di business. Essa espone un solo metodo, \texttt{get\_last\_load\_outcome(): LastLoadOutcome}, che si occupa di ottenere l'esito dell'ultimo aggiornamento del database vettoriale, di tipo LastLoadOutcome. La porta viene implementata da PostgresAdapter.

\newpage


\subsubsubsection{Adapter}
\label{sec:adapter}

\paragraph{ChromaVectorStoreAdapter}
\label{sec:chroma_vector_store_adapter}
La classe ChromaVectorStoreAdapter implementa le interfacce LoadFilesInVectorStorePort e SimilaritySearchPort, e si occupa di adattare i dati ricevuti dalla logica di business in un tipo Entity adatto per la comunicazione con il mondo esterno, e viceversa. 
Essa possiede, oltre a chroma\_vector\_store\_repository, un altro attributo privato, ricevuto tramite il costruttore, che viene chiamato da una funzione di \emph{Dependency Injection}\textsubscript{\textbf{\textit{G}}}:
\begin{itemize}
    \item \texttt{max\_chunk\_size: int}: Indica la dimensione massima di un \emph{chunk}\textsubscript{\textbf{\textit{G}}} di documenti che è possibile caricare nel database vettoriale. Per Chroma, questo valore equivale a 41.666 caratteri.
\end{itemize}
Essa espone i seguenti due metodi pubblici:
\begin{itemize}
    \item \texttt{load(documents: Document*): VectorStoreLog}: Riceve in input una lista di documenti di tipo Document, chiama il proprio metodo split per dividerli in chunk e convertirli in oggetti ChromaDocumentEntity, e si occupa di chiamare il metodo di ChromaVectorStoreRepository per caricare i documenti nel database vettoriale. Restituisce un oggetto di tipo VectorStoreLog, corrispondente al log del caricamento;
    \item \texttt{similarity\_search(user\_input: Question): Document*}: Riceve in input la domanda dell'utente di tipo Question, la converte in una stringa, e si occupa di chiamare il metodo di ChromaVectorStoreRepository per cercare i documenti similari alla domanda nel database vettoriale. Da tal metodo riceve un oggetto QueryResultEntity, che converte in una lista di documenti di tipo Document, corrispondenti ai documenti rilevanti. Questi ultimi vengono restituiti a SimilaritySearchService.
\end{itemize}
Essa contiene inoltre il seguente metodo privato:
\begin{itemize}
    \item \texttt{split(documents: Document*): ChromaDocumentEntity*}: Riceve in input una lista di documenti di tipo Document, li converte in oggetti DocumentEntity, e si occupa di dividere i documenti in chunk di dimensione massima max\_chunk\_size. Restituisce una lista di oggetti di tipo ChromaDocumentEntity, corrispondenti ai chunk di documenti.
\end{itemize}

\paragraph{LangChainAdapter}
\label{sec:langchain_adapter}
La classe LangChainAdapter implementa le interfacce GenerateAnswerPort e GetNextPossibleQuestionsPort, e si occupa di adattare i dati ricevuti dalla logica di business in un tipo Entity adatto per la comunicazione con il mondo esterno, e viceversa. 
Essa possiede, oltre a lang\_chain\_repository, un altro attributo privato, ricevuto tramite il costruttore, che viene chiamato da una funzione di Dependency Injection:
\begin{itemize}
    \item \texttt{max\_num\_tokens: int}: Indica il numero massimo di token che è possibile utilizzare per generare una risposta. Per l'LLM \emph{OpenAI}\textsubscript{\textbf{\textit{G}}} GPT-4o, questo valore equivale a 128.000.
\end{itemize}
Essa espone i seguenti due metodi pubblici:
\begin{itemize}
    \item \texttt{generate\_answer(user\_input: Question, relevant\_docs: Document*, header: Header): Answer}: Riceve in input la domanda dell'utente di tipo Question, che converte in una stringa, una lista di documenti rilevanti di tipo Document, che converte in una lista di LangChainDocumentEntity, e un oggetto Header che fornisce il contesto introduttivo al chatbot, che converte in una stringa, e si occupa di chiamare il metodo di LangChainRepository per generare una risposta. Riceve da quest'ultimo una risposta di tipo stringa, la converte in un tipo Answer e la restituisce a GenerateAnswerService;
    \item \texttt{get\_next\_possible\_questions(question\_answer\_couple: QuestionAnswerCouple, header:\\ Header): NextPossibleQuestions}: Riceve in input una coppia domanda-risposta di tipo QuestionAnswerCouple (contenente una Question e una Answer), che converte in una lista di due stringhe, e un'introduzione per dare contesto al chatbot di tipo Header, che converte in una stringa, e si occupa di chiamare il metodo di LangChainRepository per generare le possibili domande successive. Riceve da quest'ultimo una stringa, che, grazie alle istruzioni fornite dall'header, possiederà unicamente le domande e le possiederà suddivise da \_\_. Quindi, effettua il parsing della stringa ed estrapola le domande per crearci una lista di oggetti PossibleQuestion, che poi, assieme all'intero num\_questions, il cui valore eguaglia la lunghezza della lista, vengono incapsulate in un oggetto NextPossibleQuestions, che viene restituito a GetNextPossibleQuestionsService.
\end{itemize}

\paragraph{GitHubAdapter}
\label{sec:github_adapter}
La classe GitHubAdapter implementa l'interfaccia GitHubPort e si occupa di adattare i dati ricevuti dalla logica di business in un tipo Entity adatto per la comunicazione con il mondo esterno, e viceversa. Essa espone i seguenti due metodi:
\begin{itemize}
    \item \texttt{load\_github\_commits(): (PlatformLog, Document*)}: Si occupa di chiamare il metodo di GitHubRepository per recuperare i Commits da GitHub e restituire il rispettivo log. Dal repository riceve un PlatformLog e una lista di CommitEntity, e converte quest'ultima in una lista di Document. Restituisce una tupla contenente un oggetto di tipo PlatformLog, corrispondente al log, e una lista di oggetti di tipo Document, corrispondenti ai commits;
    \item \texttt{load\_github\_files(): (PlatformLog, Document*)}: Si occupa di chiamare il metodo di GitHubRepository per recuperare i Files da GitHub e restituire il rispettivo log. Dal repository riceve un PlatformLog e una lista di FileEntity, e converte quest'ultima in una lista di Document. Restituisce una tupla contenente un oggetto di tipo PlatformLog, corrispondente al log, e una lista di oggetti di tipo Document, corrispondenti ai files.
\end{itemize}

\paragraph{JiraAdapter}
\label{sec:jira_adapter}
La classe JiraAdapter implementa l'interfaccia JiraPort e si occupa di adattare i dati ricevuti dalla logica di business in un tipo Entity adatto per la comunicazione con il mondo esterno, e viceversa. Essa espone il seguente metodo:
\begin{itemize}
    \item \texttt{load\_jira\_issues(): (PlatformLog, Document*)}: Si occupa di chiamare il metodo di JiraRepository per recuperare le Issues da Jira e restituire il rispettivo log. Dal repository riceve un PlatformLog e una lista di IssueEntity, e converte quest'ultima in una lista di Document. Restituisce una tupla contenente un oggetto di tipo PlatformLog, corrispondente al log, e una lista di oggetti di tipo Document, corrispondenti alle issues.
\end{itemize}

\paragraph{ConfluenceAdapter}
\label{sec:confluence_adapter}
La classe ConfluenceAdapter implementa l'interfaccia ConfluencePort e si occupa di adattare i dati ricevuti dalla logica di business in un tipo Entity adatto per la comunicazione con il mondo esterno, e viceversa. Essa espone il seguente metodo:
\begin{itemize}
    \item \texttt{load\_confluence\_pages(): (PlatformLog, Document*)}: Si occupa di chiamare il metodo di ConfluenceRepository per recuperare le Pagine da Confluence e restituire il rispettivo log. Dal repository riceve un PlatformLog e una lista di PageEntity, e converte quest'ultima in una lista di Document. Restituisce una tupla contenente un oggetto di tipo PlatformLog, corrispondente al log, e una lista di oggetti di tipo Document, corrispondenti alle pagine.
\end{itemize}

\paragraph{PostgresAdapter}
\label{sec:postgres_adapter}
La classe PostgresAdapter implementa le interfacce GetMessagesPort, SaveMessagePort, SaveLoadingAttemptInDbPort e GetLastLoadOutcomePort, e si occupa di adattare i dati ricevuti dalla logica di business in un tipo Entity adatto per la persistenza, e viceversa. Essa espone i seguenti metodi pubblici:
\begin{itemize}
    \item \texttt{get\_messages(quantity: Quantity): Message*}: Riceve in input la quantità di messaggi da recuperare di tipo Quantity, e si occupa di convertire la quantità in un intero e di chiamare il metodo di recupero dei messaggi dal database di PostgresRepository. Riceve una lista di messaggi di tipo PostgresMessage, e restituisce, una volta opportunamente convertita, una lista di messaggi di tipo Message;
    \item \texttt{save\_message(message: Message): DbSaveOperationResponse}: Riceve in input il messaggio da salvare di tipo Message, e si occupa di chiamare il metodo di conversione del messaggio in PostgresMessage e di chiamare il metodo di salvataggio di un messaggio nel database di PostgresRepository. Riceve un oggetto di tipo PostgresSaveOperationResponse e restituisce, una volta opportunamente convertito, un oggetto di tipo DbSaveOperationResponse;
    \item \texttt{save\_loading\_attempt(loading\_attempt: LoadingAttempt): DbSaveOperationResponse}: Riceve in input il tentativo di caricamento da salvare di tipo LoadingAttempt, e si occupa di chiamare il metodo di conversione del tentativo in PostgresLoadingAttempt e di chiamare il metodo di salvataggio del tentativo di caricamento nel database di PostgresRepository. Riceve un oggetto di tipo PostgresSaveOperationResponse e restituisce, una volta opportunamente convertito, un oggetto di tipo DbSaveOperationResponse;
    \item \texttt{get\_last\_load\_outcome(): LastLoadOutcome}: Si occupa di chiamare il metodo di recupero dell'esito dell'ultimo tentativo di caricamento di documenti nel database vettoriale da PostgresRepository. Riceve un oggetto di tipo PostgresLastLoadOutcome e restituisce, una volta opportunamente convertito, un oggetto di tipo LastLoadOutcome.
\end{itemize}
Inoltre, contiene i seguenti metodi privati:
\begin{itemize}
    \item \texttt{postgres\_message\_converter(message: Message): PostgresMessage}: Riceve in input un messaggio di tipo Message, e si occupa di convertirlo in un messaggio di tipo PostgresMessage;
    \item \texttt{message\_converter(postgres\_message: PostgresMessage): Message}: Riceve in input un messaggio di tipo PostgresMessage, e si occupa di convertirlo in un messaggio di tipo Message;
    \item \texttt{dsor\_converter(psor: PostgresSaveOperationResponse): DbSaveOperationResponse}: Riceve in input un oggetto di tipo PostgresSaveOperationResponse, e si occupa di convertirlo in un oggetto di tipo DbSaveOperationResponse;
    \item \texttt{postgres\_loading\_attempt\_converter(loading\_attempt: LoadingAttempt):\\ PostgresLoadingAttempt}: Riceve in input un tentativo di caricamento di tipo LoadingAttempt, e si occupa di convertirlo in un tentativo di caricamento di tipo PostgresLoadingAttempt;
    \item \texttt{last\_load\_outcome\_converter(pllo: PostgresLastLoadOutcome): LastLoadOutcome}: Riceve in input un oggetto di tipo PostgresLastLoadOutcome, e si occupa di convertirlo in un oggetto di tipo LastLoadOutcome.
\end{itemize}

\newpage



\subsubsubsection{Repository}
\label{sec:repository}

\paragraph{ChromaVectorStoreRepository}
\label{sec:chroma_vector_store_repository}
La classe ChromaVectorStoreRepository si occupa di gestire parte della \emph{persistent logic}\textsubscript{\textbf{\textit{G}}} del sistema, ovvero di caricare i documenti nel database vettoriale \emph{Chroma}\textsubscript{\textbf{\textit{G}}} e di recuperarli compiendo una ricerca di \emph{similarità}\textsubscript{\textbf{\textit{G}}}. Essa contiene un singolo attributo privato, ricevuto tramite il costruttore, che viene chiamato da una funzione di \emph{Dependency Injection}:
\begin{itemize}
    \item \texttt{collection: Collection}: Collezione di documenti del database vettoriale Chroma, chiamata "buddybot-vector-store".
\end{itemize}
Essa espone i seguenti metodi pubblici:
\begin{itemize}
    \item \texttt{load(documents: ChromaDocumentEntity*): VectorStoreLog}: Si occupa di caricare i documenti nel database vettoriale Chroma. Riceve in input una lista di documenti di tipo ChromaDocumentEntity e li carica nel database vettoriale. Restituisce un oggetto di tipo VectorStoreLog, corrispondente al log del caricamento;
    \item \texttt{similarity\_search(user\_input: string): QueryResultEntity}: Si occupa di cercare i documenti similari alla domanda dell'utente nel database vettoriale Chroma. Riceve in input la domanda dell'utente di tipo string e la utilizza per cercare i documenti similari nel database vettoriale. Restituisce un oggetto di tipo QueryResultEntity, contenente i documenti rilevanti.
\end{itemize}

\paragraph{LangChainRepository}
\label{sec:langchain_repository}
La classe LangChainRepository si occupa di gestire parte della \emph{persistent logic}\textsubscript{\textbf{\textit{G}}} del sistema, ovvero di generare risposte a partire da domande e documenti rilevanti, e di generare possibili domande successive a partire da una domanda e una risposta. Essa contiene un singolo attributo privato, ricevuto tramite il costruttore, che viene chiamato da una funzione di \emph{Dependency Injection}:
\begin{itemize}
    \item \texttt{llm: ChatOpenAI}: Modello di \emph{LLM}\textsubscript{\textbf{\textit{G}}} di \emph{OpenAI}\textsubscript{\textbf{\textit{G}}}, più precisamente GPT-4o.
\end{itemize}
Essa espone i seguenti metodi pubblici:
\begin{itemize}
    \item \texttt{generate\_answer(user\_input: string, relevant\_docs: LangChainDocumentEntity*,\\ header: string): string}: Si occupa di generare una risposta a partire dalla domanda dell'utente e dai documenti rilevanti. Riceve in input la domanda dell'utente di tipo string, i documenti rilevanti di tipo LangChainDocumentEntity e un'introduzione per dare contesto al chatbot di tipo string. Sfrutta le funzioni della libreria \emph{LangChain}\textsubscript{\textbf{\textit{G}}} per creare il prompt e contattare l'LLM. Restituisce una stringa, corrispondente alla risposta generata;
    \item \texttt{get\_next\_possible\_questions(question\_answer\_couple: string*, header: string):\\ string}: Si occupa di generare possibili domande successive a partire da una domanda e una risposta. Riceve in input una lista di stringhe contenente la domanda dell'utente e la risposta ricevuta, e un'introduzione per dare contesto al chatbot di tipo string. Sfrutta le funzioni della libreria \emph{LangChain} per creare il prompt e contattare l'LLM. Restituisce una stringa, contenente unicamente le possibili domande successive, separate da \_\_, come da istruzioni dell'header.
\end{itemize}

\paragraph{GitHubRepository}
\label{sec:github_repository}
La classe GitHubRepository si occupa di gestire parte della \emph{persistent logic}\textsubscript{\textbf{\textit{G}}} del sistema, ovvero di recuperare i dati da \emph{GitHub}\textsubscript{\textbf{\textit{G}}}. Essa contiene un singolo attributo privato:
\begin{itemize}
    \item \texttt{github\_repo: Repository}: Repository GitHub da cui recuperare i dati, ricevuto tramite il costruttore, che viene chiamato da una funzione di \emph{Dependency Injection}.
\end{itemize}
Essa espone i seguenti metodi pubblici:
\begin{itemize}
    \item \texttt{load\_github\_commits(): (PlatformLog, CommitEntity*)}: Si occupa di recuperare i Commits da GitHub e di salvare i rispettivi log. Restituisce una tupla contenente un oggetto di tipo PlatformLog, corrispondente al log, e una lista di oggetti di tipo CommitEntity, corrispondenti ai commits;
    \item \texttt{load\_github\_files(): (PlatformLog, FileEntity*)}: Si occupa di recuperare i Files da GitHub e di salvare i rispettivi log. Restituisce una tupla contenente un oggetto di tipo PlatformLog, corrispondente al log, e una lista di oggetti di tipo FileEntity, corrispondenti ai files.
\end{itemize}

\paragraph{JiraRepository}
\label{sec:jira_repository}
La classe JiraRepository si occupa di gestire parte della \emph{persistent logic}\textsubscript{\textbf{\textit{G}}} del sistema, ovvero di recuperare i dati da \emph{Jira}\textsubscript{\textbf{\textit{G}}}. Essa contiene quattro attributi privati, ricevuti tramite il costruttore, che viene chiamato da una funzione di \emph{Dependency Injection}:
\begin{itemize}
    \item \texttt{base\_url: string}: URL di base del profilo Jira del progetto;
    \item \texttt{project\_key: string}: Chiave del progetto Jira;
    \item \texttt{timeout: int}: Timeout delle richieste;
    \item \texttt{headers: dict[string, string]}: Headers delle richieste, per gestire l'autenticazione.
\end{itemize}
Essa espone il seguente metodo:
\begin{itemize}
    \item \texttt{load\_jira\_issues(): (PlatformLog, IssueEntity*)}: Si occupa di recuperare le Issues da Jira e di salvare i rispettivi log. Restituisce una tupla contenente un oggetto di tipo PlatformLog, corrispondente al log, e una lista di oggetti di tipo IssueEntity, corrispondenti alle issues.
\end{itemize}

\paragraph{ConfluenceRepository}
\label{sec:confluence_repository}
La classe ConfluenceRepository si occupa di gestire parte della \emph{persistent logic}\textsubscript{\textbf{\textit{G}}} del sistema, ovvero di recuperare i dati da \emph{Confluence}\textsubscript{\textbf{\textit{G}}}. Essa contiene quattro attributi privati, ricevuti tramite il costruttore, che viene chiamato da una funzione di \emph{Dependency Injection}:
\begin{itemize}
    \item \texttt{base\_url: string}: URL di base del profilo Confluence del progetto;
    \item \texttt{space\_key: string}: Chiave dello spazio Confluence;
    \item \texttt{timeout: int}: Timeout delle richieste;
    \item \texttt{headers: dict[string, string]}: Headers delle richieste, per gestire l'autenticazione.
\end{itemize}
Essa espone il seguente metodo:
\begin{itemize}
    \item \texttt{load\_confluence\_pages(): (PlatformLog, PageEntity*)}: Si occupa di recuperare le Pagine da Confluence e di salvare i rispettivi log. Restituisce una tupla contenente un oggetto di tipo PlatformLog, corrispondente al log, e una lista di oggetti di tipo PageEntity, corrispondenti alle pagine.
\end{itemize}

\paragraph{PostgresRepository}
\label{sec:postgres_repository}
La classe PostgresRepository si occupa di gestire parte della \emph{persistent logic}\textsubscript{\textbf{\textit{G}}} del sistema, ovvero di gestire la persistenza dei dati, interagendo con il \emph{database relazionale}\textsubscript{\textbf{\textit{G}}} \emph{Postgres}\textsubscript{\textbf{\textit{G}}} per salvare e/o recuperare le informazioni necessarie. 
Essa contiene un singolo attributo privato, ricevuto tramite il costruttore, che viene chiamato da una funzione di \emph{Dependency Injection}:
\begin{itemize}
    \item \texttt{conn: Connection}: Connessione al database Postgres.
\end{itemize}
Essa espone i seguenti metodi pubblici:
\begin{itemize}
    \item \texttt{get\_messages(quantity: int): PostgresMessage*}: Riceve in input la quantità di messaggi di tipo intero, e si occupa di recuperare tale numero messaggi dal database. Restituisce una lista di messaggi di tipo PostgresMessage;
    \item \texttt{save\_message(message: PostgresMessage): PostgresSaveOperationResponse}: Riceve in input un messaggio di tipo PostgresMessage, e si occupa di salvarlo nel database. Restituisce un oggetto di tipo PostgresSaveOperationResponse, contenente l'esito dell'operazione e un relativo messaggio;
    \item \texttt{save\_loading\_attempt(loading\_attempt: PostgresLoadingAttempt):\\ PostgresSaveOperationResponse}: Riceve in input un tentativo di caricamento di tipo PostgresLoadingAttempt, e si occupa di salvarlo nel database. Restituisce un oggetto di tipo PostgresSaveOperationResponse, contenente l'esito dell'operazione e un relativo messaggio;
    \item \texttt{get\_last\_load\_outcome(): PostgresLoadingAttempt}: Si occupa di recuperare l'esito dell'ultimo tentativo di caricamento di documenti nel database vettoriale. Più precisamente, viene recuperato l'attributo \texttt{outcome} della tupla con timestamp di fine aggiornamento più recente dalla tabella \texttt{loading\_attempts}. Restituisce dunque un oggetto di tipo PostgresLastLoadOutcome, che può assumere valore True, se l'ultimo tentativo di aggiornamento ha avuto esito positivo, False, se l'ultimo tentativo di aggiornamento ha avuto esito negativo, o Error, se c'è stato un errore nell'interazione con Postgres per recuperare l'esito dell'ultimo aggiornamento.
\end{itemize}
Inoltre, contiene il seguente metodo privato:
\begin{itemize}
    \item \texttt{execute\_query(query: string, params: tuple, fetch\_one: bool, fetch\_all: bool):\\ tuple | list | None}: Riceve in input una stringa contenente una query \emph{SQL}\textsubscript{\textbf{\textit{G}}}, i parametri della query, e due booleani opzionali che indicano se la funzione deve restituire un solo risultato, tutti i risultati, oppure nessuno. Si occupa di eseguire la query sul database configurato e, eventualmente, di restituirne i risultati.
\end{itemize}

\newpage



\subsubsection{Frontend}
\label{sec:frontend}

\subsubsubsection{Component}
\label{sec:component}

\dots

\newpage


\subsubsubsection{Service}
\label{sec:service_frontend}

\dots

\newpage
