% Intestazione
\fancyhead[L]{1 \hspace{0.2cm} Architettura} % Testo a sinistra

\section{Architettura}
\label{sec:architettura}

Questa sezione fornisce una descrizione dettagliata dell'architettura del prodotto software, illustrando le scelte progettuali adottate per garantire la corretta realizzazione del sistema. Saranno presentati le principali scelte e \emph{pattern architetturali}\textsubscript{\textbf{\textit{G}}}, e le \emph{componenti software}\textsubscript{\textbf{\textit{G}}} che compongono il sistema.

\subsection{Architettura logica}
L’architettura adottata nella realizzazione dell’applicativo si basa sul modello di architettura esagonale. Il livello di \emph{business}\textsubscript{\textbf{\textit{G}}} del software è quindi indipendente dagli altri componenti, ovvero nulla presente all’esterno della logica di business può conoscere la sua \emph{implementazione}\textsubscript{\textbf{\textit{G}}}. Questo principio alla base dell’architettura esagonale ci permette di ottenere un prodotto software facilmente testabile e \emph{manutenibile}\textsubscript{\textbf{\textit{G}}}. Le componenti che devono restare indipendenti sono rappresentate dal \emph{Domain business model}\textsubscript{\textbf{\textit{G}}}, che non comunica mai direttamente con l’esterno.
Gli elementi che permettono il funzionamento dell’architettura esagonale sono i seguenti:
\begin{itemize}
    \item \textbf{\emph{Controller}}\textsubscript{\textbf{\textit{G}}}: contiene l'\emph{application logic}\textsubscript{\textbf{\textit{G}}} del sistema: gestisce le richieste in ingresso, valida i dati di tipo \emph{DTO}\textsubscript{\textbf{\textit{G}}} ricevuti in input, e li adatta verso un tipo di dato di business. Il \emph{Controller} ha poi il compito di chiamare uno \emph{UseCase} per eseguire la logica di business, adattare l'output in un oggetto DTO e restituirlo al client.
    \item \textbf{\emph{UseCase}}\textsubscript{\textbf{\textit{G}}}: rappresenta un caso d'uso specifico del sistema, che viene implementato da un \emph{Service} per realizzare la logica di business.
    \item \textbf{\emph{Service}}\textsubscript{\textbf{\textit{G}}}: contiene la \emph{business logic}textsubscript{\textbf{\textit{G}}} del sistema: esegue operazioni specifiche esclusive del dominio di interesse e delega le interazioni con le altre componenti ai \emph{Port}. I \emph{Service} possono interagire unicamente con tipi di dato di business, garantendo l'indipendenza della logica di business dal resto del sistema.
    \item \textbf{\emph{Port}}\textsubscript{\textbf{\textit{G}}}: definisce le interfacce attraverso le quali i \emph{Service} interagiscono con il mondo esterno, permettendo il salvataggio e recupero di dati persistenti senza modificare la logica di business.
    \item \textbf{\emph{Adapter}}\textsubscript{\textbf{\textit{G}}}: implementa una o più interfacce definite dai \emph{Port}, permettendo la comunicazione tra la logica di business e le tecnologie esterne di persistent logic. L'\emph{adapter} si occupa di adattare i dati ricevuti dalla logica di business in un tipo \emph{Entity}\textsubscript{\textbf{\textit{G}}} adatto per la persistenza, e viceversa.
    \item \textbf{\emph{Repository}}\textsubscript{\textbf{\textit{G}}}: contiene la \emph{persistent logic}textsubscript{\textbf{\textit{G}}} del sistema: gestisce la persistenza dei dati, interagendo con un database o altre forme di storage per salvare e recuperare le informazioni necessarie. I tipi di dato gestiti dal \emph{repository} sono gli Entity, che rappresentano i dati persistenti del sistema.
\end{itemize}

È stato scelto di utilizzare un'architettura esagonale per i seguenti motivi:
\begin{itemize}
    \item \textbf{Facilità di test}: l'architettura esagonale permette di testare facilmente la business logic, in quanto è possibile sostituire gli adapter con degli \emph{stub}\textsubscript{\textbf{\textit{G}}} o dei \emph{mock}\textsubscript{\textbf{\textit{G}}};
    \item \textbf{\emph{Manutenibilità}}\textsubscript{\textbf{\textit{G}}}: l'architettura esagonale permette di mantenere la business logic indipendente dagli altri componenti, facilitando la manutenzione del codice;
    \item \textbf{\emph{Scalabilità}}\textsubscript{\textbf{\textit{G}}}: l'architettura esagonale permette di aggiungere nuovi adapter senza dover modificare la business logic.
\end{itemize}


\subsection{Architettura di Deployment}
\label{sec:architettura_deployment}

Per determinare l'architettura di deployment più adatta all'applicativo, si è tenuto conto del contesto reale in cui verrà utilizzato. Poiché il sistema è destinato all'utilizzo in un azienda, dove non si prevedono significative espansioni o modifiche strutturali dopo l'installazione, la scelta di un'architettura monolitica è risultata la più appropriata. Questa soluzione, oltre a essere perfettamente in linea con le esigenze del prodotto, semplifica le fasi di progettazione, sviluppo e test. Inoltre, rispetto a un'architettura a microservizi, il monolite evita complessità che sarebbero state difficili da gestire, anche considerando le competenze attuali del team di sviluppo.\\\\
Il deployment del prodotto viene gestito attraverso la containerizzazione con \textbf{\emph{Docker Compose}}\textsubscript{\textbf{\textit{G}}}. Questa scelta consente di semplificare l’installazione dell’applicativo, fornendo un ambiente preconfigurato in cui tutte le dipendenze sono già risolte. In questo modo, vengono predisposti automaticamente tutti i servizi necessari per garantire il corretto funzionamento del sistema, riducendo le difficoltà legate alla configurazione manuale.



\subsection{Architettura di dettaglio}
\label{sec:architettura_di_dettaglio}

\subsubsection{Architettura della generazione di una risposta}
\label{sec:architettura_generazione_risposta}

\dots


\subsubsection{Architettura dell'aggiornamento automatico del database vettoriale}
\label{sec:architettura_aggiornamento_database_vettoriale}

\dots


\subsubsection{Architettura dell’inizializzazione, refresh e scroll di Angular}
\label{sec:architettura_inizializzazione_angular}

\dots


\subsubsection{Architettura dell’aggiornamento del rendering grafico durante la chat}
\label{sec:architettura_aggiornamento_rendering_chat}

\dots


\subsubsection{Architettura frontend dell’aggiornamento del badge di segnalazione dell’esito dell’ultimo aggiornamento automatico}
\label{sec:architettura_frontend_badge_aggiornamento}

\dots


\subsubsection{Architettura backend dell’aggiornamento del badge di segnalazione dell’esito dell’ultimo aggiornamento automatico}
\label{sec:architettura_backend_badge_aggiornamento}

\dots


\subsubsection{Architettura del salvataggio dei messaggi nello storico}
\label{sec:architettura_salvataggio_messaggi_storico}

\dots


\subsubsection{Architettura del recupero dei messaggi dallo storico}
\label{sec:architettura_recupero_messaggi_storico}

\dots


\subsubsection{Architettura della generazione di domande per proseguire la conversazione}
\label{sec:architettura_generazione_domande_conversazione}

\dots



\subsection{Design pattern utilizzati}
\label{sec:design_pattern_utilizzati}

\subsubsection{Architettura esagonale}
\label{sec:architettura_esagonale}

\dots


\subsubsection{Facade}
\label{sec:facade}

\dots


\subsubsection{Dependency Injection}
\label{sec:dependency_injection}

\dots


\subsubsection{MVVM}
\label{sec:mvvm}

\dots



\subsection{Descrizione delle classi}
\label{sec:descrizione_classi}

\subsubsection{Controller}
\label{sec:controller}

\dots


\subsubsection{Use Case}
\label{sec:use_case}

\dots


\subsubsection{Service}
\label{sec:service}

\dots


\subsubsection{Port}
\label{sec:port}

\dots


\subsubsection{Adapter}
\label{sec:adapter}

\dots


\subsubsection{Repository}
\label{sec:repository}

\dots


\subsubsection{Component}
\label{sec:component}

\dots
