% Intestazione
\fancyhead[L]{1 \hspace{0.2cm} Architettura} % Testo a sinistra

\section{Architettura}
\label{sec:architettura}

Questa sezione fornisce una descrizione dettagliata dell'\emph{architettura logica}\textsubscript{\textbf{\textit{G}}} del prodotto software, illustrando le scelte progettuali adottate per garantire la corretta realizzazione del sistema. Saranno presentati le principali scelte e \emph{pattern architetturali}\textsubscript{\textbf{\textit{G}}}, e le \emph{componenti software}\textsubscript{\textbf{\textit{G}}} che compongono il sistema.

\subsection{Architettura logica}
L’architettura adottata nella realizzazione dell’applicativo si basa sul modello di \emph{architettura esagonale}\textsubscript{\textbf{\textit{G}}}. Il livello di \emph{business}\textsubscript{\textbf{\textit{G}}} del software è quindi indipendente dagli altri componenti, ovvero nulla presente all’esterno della logica di business può conoscere la sua \emph{implementazione}\textsubscript{\textbf{\textit{G}}}. Questo principio alla base dell’architettura esagonale ci permette di ottenere un prodotto software facilmente testabile e \emph{manutenibile}\textsubscript{\textbf{\textit{G}}}. Le componenti che devono restare indipendenti sono rappresentate dal \emph{Domain business model}\textsubscript{\textbf{\textit{G}}}, che non comunica mai direttamente con l’esterno.
Gli elementi che permettono il funzionamento dell’architettura esagonale sono i seguenti:
\begin{itemize}
    \item \textbf{\emph{Controller}}\textsubscript{\textbf{\textit{G}}}: contiene l'\emph{application logic}\textsubscript{\textbf{\textit{G}}} del sistema: gestisce le richieste in ingresso, valida i dati di tipo \emph{DTO}\textsubscript{\textbf{\textit{G}}} ricevuti in input, e li adatta verso un tipo di dato di business. Il \emph{Controller} ha poi il compito di chiamare uno \emph{UseCase} per eseguire la logica di business, adattare l'output in un oggetto DTO e restituirlo al client.
    \item \textbf{\emph{UseCase}}\textsubscript{\textbf{\textit{G}}}: rappresenta un caso d'uso specifico del sistema, che viene implementato da un \emph{Service} per realizzare la logica di business.
    \item \textbf{\emph{Service}}\textsubscript{\textbf{\textit{G}}}: contiene la \emph{business logic}textsubscript{\textbf{\textit{G}}} del sistema: esegue operazioni specifiche esclusive del dominio di interesse e delega le interazioni con le altre componenti ai \emph{Port}. I \emph{Service} possono interagire unicamente con tipi di dato di business, garantendo l'indipendenza della logica di business dal resto del sistema.
    \item \textbf{\emph{Port}}\textsubscript{\textbf{\textit{G}}}: definisce le interfacce attraverso le quali i \emph{Service} interagiscono con il mondo esterno, permettendo il salvataggio e recupero di dati persistenti senza modificare la logica di business.
    \item \textbf{\emph{Adapter}}\textsubscript{\textbf{\textit{G}}}: implementa una o più interfacce definite dai \emph{Port}, permettendo la comunicazione tra la logica di business e le tecnologie esterne di persistent logic. L'\emph{adapter} si occupa di adattare i dati ricevuti dalla logica di business in un tipo \emph{Entity}\textsubscript{\textbf{\textit{G}}} adatto per la persistenza, e viceversa.
    \item \textbf{\emph{Repository}}\textsubscript{\textbf{\textit{G}}}: contiene la \emph{persistent logic}textsubscript{\textbf{\textit{G}}} del sistema: gestisce la persistenza dei dati, interagendo con un database o altre forme di storage per salvare e recuperare le informazioni necessarie. I tipi di dato gestiti dal \emph{repository} sono gli Entity, che rappresentano i dati persistenti del sistema.
\end{itemize}

È stato scelto di utilizzare un'architettura esagonale per i seguenti motivi:
\begin{itemize}
    \item \textbf{Facilità di test}: l'architettura esagonale permette di testare facilmente la business logic, in quanto è possibile sostituire gli adapter con degli \emph{stub}\textsubscript{\textbf{\textit{G}}} o dei \emph{mock}\textsubscript{\textbf{\textit{G}}};
    \item \textbf{\emph{Manutenibilità}}\textsubscript{\textbf{\textit{G}}}: l'architettura esagonale permette di mantenere la business logic indipendente dagli altri componenti, facilitando la manutenzione del codice;
    \item \textbf{\emph{Scalabilità}}\textsubscript{\textbf{\textit{G}}}: l'architettura esagonale permette di aggiungere nuovi adapter senza dover modificare la business logic.
\end{itemize}


\subsection{Architettura di Deployment}
\label{sec:architettura_deployment}

Per determinare l'\emph{architettura di deployment}\textsubscript{\textbf{\textit{G}}} più adatta all'applicativo, si è tenuto conto del contesto reale in cui verrà utilizzato. Poiché il sistema è destinato all'utilizzo in un azienda, dove non si prevedono significative espansioni o modifiche strutturali dopo l'installazione, la scelta di un'architettura monolitica è risultata la più appropriata. Questa soluzione, oltre a essere perfettamente in linea con le esigenze del prodotto, semplifica le fasi di progettazione, sviluppo e test. Inoltre, rispetto a un'architettura a microservizi, il monolite evita complessità che sarebbero state difficili da gestire, anche considerando le competenze attuali del team di sviluppo.\\\\
Il deployment del prodotto viene gestito attraverso la containerizzazione con \textbf{\emph{Docker Compose}}\textsubscript{\textbf{\textit{G}}}. Questa scelta consente di semplificare l’installazione dell’applicativo, fornendo un ambiente preconfigurato in cui tutte le dipendenze sono già risolte. In questo modo, vengono predisposti automaticamente tutti i servizi necessari per garantire il corretto funzionamento del sistema, riducendo le difficoltà legate alla configurazione manuale.



\subsection{Architettura di dettaglio}
\label{sec:architettura_di_dettaglio}

\subsubsection{Architettura della generazione di una risposta}
\label{sec:architettura_generazione_risposta}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura della generazione di una risposta}
\end{figure}

L'UML in questione rappresenta l'\emph{architettura}\textsubscript{\textbf{\textit{G}}} della generazione di una risposta all'interrogazione di un utente, dal punto di vista del \emph{backend}\textsubscript{\textbf{\textit{G}}}.
Quando il \emph{frontend}\textsubscript{\textbf{\textit{G}}} invia al backend il messaggio dell'utente, in forma di dizionario, esso viene recuperato dal ChatController, che converte la stringa interna al dizionario in un oggetto di Business, Question, e lo invia all'interfaccia ChatUseCase, implementata da ChatService.
ChatService, quindi, chiama SimilaritySearchService, componente responsabile della ricerca di \emph{similarità}\textsubscript{\textbf{\textit{G}}} nel \emph{database vettoriale}\textsubscript{\textbf{\textit{G}}}, il quale si collega con SimilaritySearchPort verso l'esterno, sfruttando l'\emph{architettura esagonale}\textsubscript{\textbf{\textit{G}}}. La Porta viene implementata da ChromaVectorStoreAdapter, che adatta la Question verso un tipo stringa inviato a ChromaVectorStoreRepository, che gestisce il collegamento con il database vettoriale \emph{Chroma}\textsubscript{\textbf{\textit{G}}}, sul quale avviene la ricerca di similarità. Una volta ottenuti i risultati della ricerca e trasformati in \emph{Entity}\textsubscript{\textbf{\textit{G}}}, essi vengono convertiti nel tipo di Business Document e restituiti a ChatService, il quale poi li invia assieme all'input dell'utente a GenerateAnswerService, classe di servizio munita di un attributo Header che consente di fornire un introduzione di contesto al chatbot. Header, input utente e documenti rilevanti vengono quindi forniti a LangChainAdapter, che si assicura che la somma dei \emph{token}\textsubscript{\textbf{\textit{G}}} dei parametri non superi la soglia limite per l'\emph{LLM}\textsubscript{\textbf{\textit{G}}} configurato. Infine, i parametri vengono forniti a LangChainRepository, che li combina assieme in unico prompt e, sfruttando gli strumenti forniti dalla libreria \emph{LangChain}\textsubscript{\textbf{\textit{G}}}, effettua una chiamata verso l'LLM di \emph{OpenAI}\textsubscript{\textbf{\textit{G}}}, selezionato tramite una variabile d'ambiente, per ottenere una risposta. 
La risposta viene quindi convertita in un oggetto Answer di \emph{Business Logic}\textsubscript{\textbf{\textit{G}}} ed infine convertita in stringa per essere inserita in un dizionario in ChatController, il quale infine restituisce la risposta al frontend.


\subsubsection{Architettura dell'aggiornamento automatico del database vettoriale}
\label{sec:architettura_aggiornamento_database_vettoriale}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura dell'aggiornamento automatico del database vettoriale}
\end{figure}

\dots


\subsubsection{Architettura dell’inizializzazione, refresh e scroll di Angular}
\label{sec:architettura_inizializzazione_angular}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura dell’inizializzazione, refresh e scroll di Angular}
\end{figure}

\dots


\subsubsection{Architettura dell’aggiornamento del rendering grafico durante la chat}
\label{sec:architettura_aggiornamento_rendering_chat}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura dell’aggiornamento del rendering grafico durante la chat}
\end{figure}

\dots


\subsubsection{Architettura frontend dell’aggiornamento del badge di segnalazione dell’esito dell’ultimo aggiornamento automatico}
\label{sec:architettura_frontend_badge_aggiornamento}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura frontend dell’aggiornamento del badge di segnalazione dell’esito dell’ultimo aggiornamento automatico}
\end{figure}

\dots


\subsubsection{Architettura backend dell’aggiornamento del badge di segnalazione dell’esito dell’ultimo aggiornamento automatico}
\label{sec:architettura_backend_badge_aggiornamento}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura backend dell’aggiornamento del badge di segnalazione dell’esito dell’ultimo aggiornamento automatico}
\end{figure}

\dots


\subsubsection{Architettura del salvataggio dei messaggi nello storico}
\label{sec:architettura_salvataggio_messaggi_storico}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura del salvataggio dei messaggi nello storico}
\end{figure}

\dots


\subsubsection{Architettura del recupero dei messaggi dallo storico}
\label{sec:architettura_recupero_messaggi_storico}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura del recupero dei messaggi dallo storico}
\end{figure}

\dots


\subsubsection{Architettura della generazione di domande per proseguire la conversazione}
\label{sec:architettura_generazione_domande_conversazione}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{placeholder.png}
    \caption{Architettura della generazione di domande per proseguire la conversazione}
\end{figure}

\dots



\subsection{Design pattern utilizzati}
\label{sec:design_pattern_utilizzati}

\subsubsection{Architettura esagonale}
\label{sec:architettura_esagonale}

\dots


\subsubsection{Facade}
\label{sec:facade}

\dots


\subsubsection{Dependency Injection}
\label{sec:dependency_injection}

\dots


\subsubsection{MVVM}
\label{sec:mvvm}

\dots



\subsection{Descrizione delle classi}
\label{sec:descrizione_classi}

\subsubsection{Backend}
\label{sec:backend}

\subsubsubsection{Controller}
\label{sec:controller}

\dots


\subsubsubsection{Use Case}
\label{sec:use_case}

\dots


\subsubsubsection{Service}
\label{sec:service_backend}

\dots


\subsubsubsection{Port}
\label{sec:port}

\dots


\subsubsubsection{Adapter}
\label{sec:adapter}

\dots


\subsubsubsection{Repository}
\label{sec:repository}

\dots



\subsubsection{Frontend}
\label{sec:frontend}

\subsubsubsection{Component}
\label{sec:component}

\dots


\subsubsubsection{Service}
\label{sec:service_frontend}

\dots
